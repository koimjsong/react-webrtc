/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/js/constants.js":
/*!********************************!*\
  !*** ./public/js/constants.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KOI_OCR_EVENT: () => (/* binding */ KOI_OCR_EVENT),\n/* harmony export */   OCR_TYPE: () => (/* binding */ OCR_TYPE),\n/* harmony export */   buttonsData: () => (/* binding */ buttonsData),\n/* harmony export */   rtcType: () => (/* binding */ rtcType)\n/* harmony export */ });\nconst KOI_OCR_EVENT = {\n  READY: \"ready\",\n  RESULT: \"result\",\n  PROGRESS: \"progress\",\n  CAMERA_STARTED: \"camerastarted\",\n  CAPTURE: \"capture\"\n};\nconst OCR_TYPE = {\n  IDCARD: 1,\n  // 주민등록증, 운전면허증, 여권(외국인등록증 미포함) WASM\n  PASSPORT: 2,\n  // 여권 MRZ WASM\n  CREDITCARD: 3,\n  // 신용카드 API\n  QRCODE: 4,\n  // QR/Barcode WASM\n  SEALCERT: 5,\n  // 인감증명서\n  BIZREGCERT: 6,\n  // 사업자등록증\n  CROP: 7,\n  // 문서 crop WASM\n  ACCOUNT: 8,\n  // 계좌번호 인식\n  CHECK: 9,\n  // 수표 인식\n  GIRO: 10,\n  // 지로번호 인식\n  IDFAKE: 11,\n  // 사본판별\n  GIROEPN: 12,\n  // 지로 전자납부번호 인식\n  IDFACE: 13,\n  // 안면인증\n  DOCS: 14,\n  // 정형문서\n  FULLPAGE: 15,\n  // 전문인식\n  CROPLIVE: 16 // 문서 crop server\n};\nconst rtcType = {\n  AUTO: 1,\n  MANUAL: 2,\n  FILE: 3,\n  CAPTURE: 4\n};\nconst buttonsData = [\n// { id: \"passport\", imgSrc: \"./images/passport_image.png\", type: OCR_TYPE.PASSPORT },\n// { id: \"qr_barcode\", imgSrc: \"./images/qr_image.png\", type: OCR_TYPE.QRCODE },\n{\n  id: \"idcard\",\n  imgSrc: \"./images/idcard.png\",\n  type: OCR_TYPE.IDCARD\n}, {\n  id: \"idfake\",\n  imgSrc: \"./images/idcard.png\",\n  type: OCR_TYPE.IDFAKE\n}, {\n  id: \"card\",\n  imgSrc: \"./images/credit.jpg\",\n  type: OCR_TYPE.CREDITCARD\n},\n// { id: \"docs_edge\", imgSrc: \"./images/crop.png\", type: OCR_TYPE.CROP },\n{\n  id: \"account\",\n  imgSrc: \"./images/account.jpg\",\n  type: OCR_TYPE.ACCOUNT\n}, {\n  id: \"giro\",\n  imgSrc: \"./images/giro.jpg\",\n  type: OCR_TYPE.GIRO\n}, {\n  id: \"giroEPN\",\n  imgSrc: \"./images/giro_epn.jpg\",\n  type: OCR_TYPE.GIROEPN\n}, {\n  id: \"crops\",\n  imgSrc: \"./images/docs.jpg\",\n  type: OCR_TYPE.CROPLIVE\n}];\n\n//# sourceURL=webpack://koiOcr/./public/js/constants.js?");

/***/ }),

/***/ "./public/js/koiOcr/koiOcr.js":
/*!************************************!*\
  !*** ./public/js/koiOcr/koiOcr.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KOI_OCR_EVENT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT),\n/* harmony export */   OCR_TYPE: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE),\n/* harmony export */   \"default\": () => (/* binding */ KoiOcr),\n/* harmony export */   rtcType: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.rtcType)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./public/js/constants.js\");\n/* harmony import */ var _koiutils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./koiutils.js */ \"./public/js/koiOcr/koiutils.js\");\n/* harmony import */ var _webCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webCamera.js */ \"./public/js/koiOcr/webCamera.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\nclass KoiOcr extends EventTarget {\n  constructor(options) {\n    super();\n    _defineProperty(this, \"_webCamera\", void 0);\n    _defineProperty(this, \"_ocrWorker\", void 0);\n    _defineProperty(this, \"_ocrProcessor\", void 0);\n    _defineProperty(this, \"_IdCardOCRProcessor\", void 0);\n    _defineProperty(this, \"_Barcode\", void 0);\n    _defineProperty(this, \"_DocsAffine\", void 0);\n    _defineProperty(this, \"_cropProcessor\", void 0);\n    _defineProperty(this, \"_ocrType\", _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.PASSPORT);\n    _defineProperty(this, \"_rtcType\", _constants_js__WEBPACK_IMPORTED_MODULE_0__.rtcType.MANUAL);\n    _defineProperty(this, \"_options\", void 0);\n    _defineProperty(this, \"_useWasmOcr\", void 0);\n    _defineProperty(this, \"_useCapOcr\", void 0);\n    _defineProperty(this, \"_useDetect\", void 0);\n    _defineProperty(this, \"_points\", void 0);\n    _defineProperty(this, \"_serverUrls\", {});\n    _defineProperty(this, \"_isOcrRequestSent\", false);\n    _defineProperty(this, \"_isProcessing\", false);\n    _defineProperty(this, \"_isResultDispatched\", false);\n    _defineProperty(this, \"_isPaused\", false);\n    _defineProperty(this, \"_successCount\", 0);\n    _defineProperty(this, \"_requestQueue\", []);\n    this._webCamera = new _webCamera_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    this._initEventHandler();\n    this.initialize();\n  }\n  async initialize() {\n    try {\n      this._getUsers = await this._webCamera.getUsers();\n    } catch (err) {\n      console.error(\"카메라 권한 허가 실패:\", err);\n    }\n  }\n  async init(options) {\n    if (options.ocrWorkerJs && !this.ocrWorkerJs) {\n      this._ocrWorker = new Worker(options.ocrWorkerJs);\n    }\n    const defaultOptions = {\n      useWebCamera: true,\n      cameraOptions: {},\n      useWasmOcr: true,\n      ocrType: _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.PASSPORT\n    };\n    // 기본 옵션과 제공된 옵션을 병합하여 this._options 설정\n    this._options = _objectSpread(_objectSpread({}, defaultOptions), options);\n    this._requestQueue = [];\n    this._ocrType = this._options.ocrType;\n    this._useWasmOcr = this._options.useWasmOcr;\n    this._useDemo = this._options.useDemo;\n    this._cameraOptions = this._options.cameraOptions;\n    this._cameraOptions.useDemo = this._useDemo;\n    this._useCapOcr = this._cameraOptions.useCapOcr;\n    this._useDetect = this._cameraOptions.useDetect;\n    this._iseDetectRetry = this._cameraOptions.detectRetry;\n    this._webCamera.setOptions(this._cameraOptions, this._getUsers);\n  }\n  get useWebCamera() {\n    return this._webCamera != null;\n  }\n  get useWasmOcr() {\n    return this._ocrProcessor != null && this._IdCardOCRProcessor != null;\n  }\n  _initEventHandler() {\n    if (this.useWebCamera) {\n      this._webCamera.addEventListener(\"webcamready\", event => {\n        this.dispatchReadyEvent();\n        // return KOI_OCR_EVENT.CAMERA_STARTED;\n      });\n      this._webCamera.addEventListener(\"imagecaptured\", async event => {\n        this.dispatchCaptureEvent();\n        if (await this.processImage(event.detail)) {\n          event.preventDefault();\n        }\n      });\n    }\n    document.addEventListener(\"touchmove\", function (event) {\n      if (event.touches.length > 1 || event.scale && event.scale !== 1) return;\n      if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {\n        event.preventDefault();\n      }\n    }, {\n      passive: false\n    });\n\n    // fileUpload 이벤트 리스너 설정\n    window.addEventListener(\"fileUpload\", async event => {\n      this.dispatchCaptureEvent();\n\n      // startFile 메서드를 호출하여 event.detail을 전달\n      if (this._webCamera && this._webCamera.startFile) {\n        this._webCamera.startFile(event.detail);\n      }\n    });\n    window.addEventListener(\"imageProcessed\", async event => {\n      this.dispatchCaptureEvent();\n      const {\n        imageData,\n        imageWidth,\n        imageHeight,\n        totalCount,\n        currentCount,\n        ocrType,\n        validCheckDt,\n        rtcToken,\n        detectTime\n      } = event.detail;\n      let eventType = \"result\";\n      const eventDetail = {\n        success: false,\n        imageData,\n        imageWidth,\n        imageHeight,\n        ocrResult: null,\n        type: ocrType\n      };\n      if (this._useDemo) {\n        if (await this.sendToOcrWorkerDemo(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, detectTime)) {\n          event.preventDefault();\n        } // demo\n      } else {\n        if (await this.sendToOcrWorker(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, detectTime)) {\n          event.preventDefault();\n        }\n      }\n      this.dispatchEvent(new CustomEvent(eventType, {\n        detail: eventDetail\n      }));\n      return eventType == _constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.RESULT;\n    });\n    window.addEventListener(\"beforeunload\", event => {\n      // WebAssembly 모듈 초기화\n      if (this.useWasmOcr) {\n        this._ocrProcessor.unload();\n        this._IdCardOCRProcessor.unload();\n        this._DocsAffine.unload();\n        this._Barcode.unload();\n      }\n    });\n  }\n  async processImage(data) {\n    const {\n      imageData,\n      imageWidth,\n      imageHeight,\n      totalCount,\n      currentCount,\n      validCheckDt,\n      rtcToken,\n      resultCode,\n      detectTime\n    } = data;\n    const eventDetail = {\n      success: false,\n      imageData,\n      imageWidth,\n      imageHeight,\n      ocrResult: null\n    };\n    try {\n      let eventType;\n      if (imageData && this._useCapOcr != 4) {\n        eventType = await this.processOCR(imageData, imageWidth, imageHeight, eventDetail, totalCount, currentCount, this._ocrType, validCheckDt, rtcToken, resultCode, detectTime);\n      } else {\n        const result = null;\n        eventType = await this.processOCRResult(result, eventDetail, totalCount, currentCount, imageData, validCheckDt, rtcToken, resultCode, detectTime);\n      }\n      this.dispatchEvent(new CustomEvent(eventType, {\n        detail: eventDetail\n      }));\n      return eventType == _constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.RESULT;\n    } catch (error) {\n      console.error(\"Error processing image:\", error.message);\n      // 적절한 에러 처리 추가\n    }\n  }\n  async processOCR(imageData, imageWidth, imageHeight, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, resultCode, detectTime) {\n    // const methodValue = document.getElementById(\"methodId\").value;\n    if (this._useDetect && this._ocrType == 1 && !this._useDemo) {\n      // 탐지(WASM) -> 인식(서버)\n      return await this.sendToOcrWorker(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, detectTime);\n    } else if (this._useWasmOcr && !this._useDemo) {\n      // WASM\n      return await this.processWasm(imageData, imageWidth, imageHeight, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, resultCode, detectTime);\n    } else if (this._useDemo) {\n      if (this._useWasmOcr) {\n        return await this.processWasm(imageData, imageWidth, imageHeight, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, resultCode, detectTime);\n      } else {\n        if (methodValue == \"0014\") {\n          return await this.sendToImgDemo(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken);\n        } else {\n          return await this.sendToOcrWorkerDemo(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, resultCode, detectTime);\n        }\n      }\n    } else {\n      // WASM 아닌 경우\n      return await this.sendToOcrWorker(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, detectTime);\n    }\n  }\n  async processWasm(imageData, imageWidth, imageHeight, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, resultCode, detectTime) {\n    let result = null;\n    try {\n      if (ocrType == 2) {\n        // 여권\n        return await this.sendToWasmWorker(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt);\n      } else if (ocrType == 4) {\n        // 바코드\n        result = this._Barcode.decode(imageData.data, imageWidth, imageHeight);\n      } else if (ocrType == 1) {\n        // 신분증\n        result = this._IdCardOCRProcessor.ocr(imageData, imageWidth, imageHeight);\n      } else if (ocrType == 7) {\n        // 문서 crop\n        result = await this.processDocumentAffine(imageData, eventDetail, imageWidth, imageHeight);\n      } else if (ocrType == 16) {\n        // console.log(\"eventDetail: \", eventDetail);\n        // result = await this.sendToResultDemo(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, resultCode, detectTime);\n      }\n    } catch (error) {\n      console.error(\"Error:\", error.message);\n      alert(\"Error:\" + error.message);\n      // OCR 실패 시에 대한 처리 추가\n    }\n    return this.processOCRResult(result, eventDetail, totalCount, currentCount, imageData, validCheckDt, rtcToken, resultCode, detectTime);\n  }\n  async sendToWasmWorker(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt) {\n    // 워커 종료 상태 초기화\n    if (!this._wasmWorker) {\n      console.log(\"워커가 초기화되지 않았습니다.\");\n      return;\n    }\n    // 현재 요청을 큐에 추가\n    this._requestQueue.push({\n      imageData,\n      eventDetail,\n      totalCount,\n      currentCount,\n      ocrType,\n      validCheckDt\n    });\n    // 현재 요청이 처리 중이지 않으면 다음 요청을 처리\n    if (!this._isProcessing) {\n      await this.processQueue(); // 큐 처리 시작\n    }\n  }\n  async processQueue() {\n    // 큐가 비어있지 않을 때까지 반복\n    while (this._requestQueue.length > 0) {\n      this._isProcessing = true; // 처리 중 상태로 설정\n      // const { imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt } = this._requestQueue.shift();\n      this._currentRequest = this._requestQueue.shift();\n      const {\n        imageData,\n        ocrType,\n        validCheckDt\n      } = this._currentRequest;\n      const result = await this.processRequest(imageData, ocrType, validCheckDt);\n      this.handleResult(result); // 결과 처리\n    }\n    this._isProcessing = false; // 큐가 비었으므로 처리 종료\n    this._currentRequest = null;\n  }\n  processRequest(imageData, ocrType, validCheckDt) {\n    return new Promise((resolve, reject) => {\n      if (this._wasmWorker) {\n        if (this._isResultDispatched) {\n          resolve(null);\n          return;\n        }\n        this._wasmWorker.postMessage({\n          type: \"detect\",\n          imageData: imageData,\n          width: imageData.width,\n          height: imageData.height,\n          ocrType: ocrType,\n          validCheckDt: validCheckDt\n        });\n        this._wasmWorker.onmessage = e => {\n          if (e.data.type == \"detectResult\") {\n            e.data.ocrResult = {\n              resultJSON: e.data.result.resultJSON\n            };\n            e.data.imageData = imageData;\n            if (e.data.ocrResult.resultJSON.resultCode == \"0000\") {\n              this._successCount++;\n              if (!this._isResultDispatched) {\n                if (this._successCount >= 1 || validCheckDt) {\n                  e.data.success = true;\n                  this.dispatchResultEvent(e.data);\n                  this._isResultDispatched = true;\n                  this._isProcessing = false;\n                  this._requestQueue = [];\n                }\n              }\n            } else {\n              resolve(e.data.ocrResult);\n              this.dispatchCropEvent(e.data);\n            }\n          } else {\n            reject(new Error(\"Unexpected message type\"));\n          }\n        };\n      } else {\n        resolve(null);\n      }\n    });\n  }\n  handleWorkerMessage(event) {\n    // 워커로부터 메시지를 처리하는 로직\n    console.log(\"워커로부터 메시지를 받았습니다:\", event.data);\n  }\n  handleResult(result) {\n    // 결과 처리 로직\n    if (result) {\n      // 처리할 로직\n    }\n  }\n  async processWasmDemo(imageData, imageWidth, imageHeight, eventDetail, totalCount, currentCount, ocrType) {\n    let result = null;\n    try {\n      if (ocrType == 2) {\n        // 여권\n        result = await this.sendToWasmWorker(imageData, eventDetail, totalCount, currentCount, ocrType);\n      } else if (ocrType == 4) {\n        // 바코드\n        result = this._Barcode.decode(imageData.data, imageWidth, imageHeight);\n      } else if (ocrType == 1) {\n        // 신분증\n        result = this._IdCardOCRProcessor.ocr(imageData, imageWidth, imageHeight);\n      } else if (ocrType == 7) {\n        // 문서 crop\n        result = await this.processDocumentAffine(imageData, eventDetail, imageWidth, imageHeight);\n      }\n    } catch (error) {\n      console.error(\"Error:\", error.message);\n      alert(\"Error:\" + error.message);\n      // OCR 실패 시에 대한 처리 추가\n    }\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = imageData.width;\n    canvas.height = imageData.height;\n    const context = canvas.getContext(\"2d\");\n    context.putImageData(imageData, 0, 0);\n    const base64Data = canvas.toDataURL(\"image/jpeg\").split(\",\")[1];\n    const messageData = {\n      imageData: {\n        srcFile: base64Data\n      },\n      resultJSON: result\n      // imageDiv: someImageDiv, // 필요한 경우에 맞게 설정\n      // methodValue: someMethodValue, // 필요한 경우에 맞게 설정\n    };\n    window.opener.postMessage(JSON.stringify(messageData), \"*\");\n    // window.close();\n    // return this.processOCRResult(result, eventDetail, totalCount, currentCount, imageData);\n  }\n  async sendToOcrWorker(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, detectTime) {\n    // const startTime = getCurrentTimeWithMilliseconds();\n    // eventDetail.startTime = startTime;\n    const result = await new Promise((resolve, reject) => {\n      const canvas = document.createElement(\"canvas\");\n      let base64Data = null;\n      if (imageData instanceof ImageData) {\n        canvas.width = imageData.width;\n        canvas.height = imageData.height;\n        const context = canvas.getContext(\"2d\");\n        context.putImageData(imageData, 0, 0);\n        base64Data = canvas.toDataURL(\"image/jpeg\").split(\",\")[1];\n      } else {\n        // 이미 base64 형식이면 그대로 사용\n        base64Data = imageData.split(\",\")[1];\n      }\n      const fileData = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.base64toBlob(base64Data, \"image/jpeg\");\n      const fileSizeInBytes = fileData.size; // 파일 크기를 바이트 단위로 가져옴\n      const fileSizeInKB = (fileSizeInBytes / 1024).toFixed(2); // KB 단위로 변환하고 소수점 두 자리까지 출력\n\n      // 이미지의 width와 height를 확인\n\n      const imageWidth = imageData.width;\n      const imageHeight = imageData.height;\n\n      // console.log(`File size: ${fileSizeInKB} KB`);\n      // console.log(`Image dimensions: ${imageWidth} x ${imageHeight}`);\n      // alert(`File size: ${fileSizeInKB} KB\\nImage width: ${imageWidth}, Image height: ${imageHeight}`);\n\n      if (this._ocrWorker && !this._isOcrRequestSent) {\n        this._isOcrRequestSent = true;\n        this._ocrWorker.postMessage({\n          ocrType,\n          base64Data,\n          validCheck: validCheckDt\n        });\n        this._ocrWorker.onmessage = e => {\n          if (e.data.type == \"ocrResult\") {\n            const ocrResult = e.data.message;\n            // const endTime = getCurrentTimeWithMilliseconds();\n            // eventDetail.endTime = endTime;\n            eventDetail.ocrType = ocrType;\n            resolve(ocrResult); // Resolve the promise with the OCR result\n\n            this._isOcrRequestSent = false; // Set the flag to true to indicate the request has been sent\n          }\n        };\n      } else {\n        resolve(null); // Resolve with null if the worker is not available or request is already sent\n      }\n    });\n    // const endTime = getCurrentTimeWithMilliseconds();\n    // eventDetail.endTime = endTime;\n    return this.processOCRResult(result, eventDetail, totalCount, currentCount, imageData, validCheckDt, rtcToken, detectTime);\n  }\n\n  // 시연 서버 요청\n  async sendToOcrWorkerDemo(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, resultCode, detectTime) {\n    const result = await new Promise((resolve, reject) => {\n      const canvas = document.createElement(\"canvas\");\n      let base64Data = null;\n      if (imageData instanceof ImageData) {\n        canvas.width = imageData.width;\n        canvas.height = imageData.height;\n        const context = canvas.getContext(\"2d\");\n        context.putImageData(imageData, 0, 0);\n        base64Data = canvas.toDataURL(\"image/jpeg\");\n      } else {\n        // 이미 base64 형식이면 그대로 사용\n        // base64Data = imageData.split(\",\")[1];\n        base64Data = imageData;\n      }\n      const methodValue = document.getElementById(\"methodId\").value;\n      const typeValue = document.getElementById(\"typeId\").value;\n      const licenseKey = document.getElementById(\"licenseKey\").value;\n      const rtcLicenseKey = rtcToken;\n      var formData = new FormData();\n      let validCheck = validCheckDt;\n      let maskOption = true;\n      const fileName = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.generateFileName(); // 기본값으로 호출 (prefix \"rtc_\", extension \".jpg\")\n      formData.append(\"file\", dataURLtoBlob(base64Data), fileName);\n      formData.append(\"maskOption\", maskOption);\n      formData.append(\"validCheck\", validCheck);\n      formData.append(\"ocrType\", typeValue);\n      formData.append(\"method\", methodValue);\n      formData.append(\"licenseKey\", licenseKey);\n      formData.append(\"rtcTransId\", rtcLicenseKey);\n      const requestUrl = \"/ocr-api/request\";\n      koi.Ajax.fnOcrFileAjax(requestUrl, formData, function (data) {\n        if (data) {\n          const ocrResult = {\n            resultJSON: data.resultData\n          };\n          eventDetail.ocrType = ocrType;\n          resolve(ocrResult);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n    return this.processOCRResult(result, eventDetail, totalCount, currentCount, imageData, validCheckDt, rtcToken, resultCode, detectTime);\n  }\n  async sendToResultDemo(imageData, eventDetail, totalCount, currentCount, ocrType, validCheckDt, rtcToken, resultCode, detectTime) {\n    const result = await new Promise((resolve, reject) => {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = imageData.width;\n      canvas.height = imageData.height;\n      const context = canvas.getContext(\"2d\");\n      context.putImageData(imageData, 0, 0);\n      const base64Data = canvas.toDataURL(\"image/jpeg\");\n      const methodValue = document.getElementById(\"methodId\").value;\n      const typeValue = document.getElementById(\"typeId\").value;\n      const licenseKey = document.getElementById(\"licenseKey\").value;\n      const rtcLicenseKey = rtcToken;\n      const resultData = resultCode;\n      var formData = new FormData();\n      let validCheck = validCheckDt;\n      let maskOption = true;\n      const fileName = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.generateFileName(); // 기본값으로 호출 (prefix \"rtc_\", extension \".jpg\")\n      formData.append(\"file\", dataURLtoBlob(base64Data), fileName);\n      formData.append(\"maskOption\", maskOption);\n      formData.append(\"validCheck\", validCheck);\n      formData.append(\"type\", typeValue);\n      formData.append(\"method\", methodValue);\n      formData.append(\"licenseKey\", licenseKey);\n      formData.append(\"rtcTransId\", rtcLicenseKey);\n      formData.append(\"result\", resultData);\n      const requestUrl = \"/ocr-api/result\";\n      koi.Ajax.fnOcrResultAjax(requestUrl, formData);\n    });\n    return this.processOCRResult(result, eventDetail, totalCount, currentCount, imageData, validCheckDt, rtcToken, resultCode, detectTime);\n  }\n  async sendToImgDemo(imageData, eventDetail, totalCount, currentCount, ocrType) {\n    const result = await new Promise((resolve, reject) => {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = imageData.width;\n      canvas.height = imageData.height;\n      const context = canvas.getContext(\"2d\");\n      context.putImageData(imageData, 0, 0);\n      const imageDivision = document.getElementById(\"imageDiv\").value;\n      const methodValue = document.getElementById(\"methodId\").value;\n      const base64Data = canvas.toDataURL(\"image/png\").split(\",\")[1];\n      const base64DataURL = canvas.toDataURL(\"image/png\");\n\n      //const base64Data = JSON.stringify({ srcFile: base64String });\n      // console.log(\"base64Data: \", base64Data);\n\n      const validCheck = currentCount < totalCount;\n      const messageData = {\n        imageData: {\n          srcFile: base64DataURL\n        },\n        imageDiv: imageDivision,\n        methodValue: methodValue,\n        validCheck: validCheck\n      };\n      window.opener.postMessage(JSON.stringify(messageData), \"*\");\n      window.close();\n    });\n    // return this.processOCRResult(result, eventDetail, totalCount, currentCount, imageData);\n  }\n  async processDocumentAffine(imageData, eventDetail, imageWidth, imageHeight) {\n    return new Promise((resolve, reject) => {\n      const resultPoints = this._DocsAffine.getPoints(imageData, imageWidth, imageHeight);\n      let points = [];\n      points = resultPoints.resultJSON.points;\n      this._points = points;\n\n      // this._points 배열에서 -1이 있는지 확인\n      const hasNegativeOne = this._points.some(point => point.x == -1 || point.y == -1);\n      if (!hasNegativeOne) {\n        const kwcGuideArea = document.getElementById(\"kwcGuideArea\");\n        kwcGuideArea.style.border = \"0px\";\n        const guideAreaRect = kwcGuideArea.getBoundingClientRect();\n        kwcGuideArea.style.zIndex = \"10002\";\n        const modal = document.createElement(\"div\");\n        modal.classList.add(\"affineDiv\");\n        modal.style.display = \"flex\";\n        modal.style.justifyContent = \"center\";\n        modal.style.width = \"100%\";\n        modal.style.height = \"100%\";\n        modal.style.alignItems = \"center\";\n        const modalContent = document.createElement(\"modalContent\");\n        modalContent.classList.add(\"affineContent\");\n        modal.appendChild(modalContent);\n        kwcGuideArea.appendChild(modal);\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = imageData.width;\n        canvas.height = imageData.height;\n        const context = canvas.getContext(\"2d\");\n        context.putImageData(imageData, 0, 0);\n        const guideImage = document.createElement(\"img\");\n        guideImage.id = \"guideImage\";\n        const imageDataURL = canvas.toDataURL(\"image/jpeg\");\n        guideImage.src = imageDataURL;\n        modalContent.appendChild(guideImage);\n        guideImage.style.width = \"100%\";\n        guideImage.style.height = \"100%\";\n        const radius = 10; // 포인트의 반지름을 설정합니다.\n\n        let affinePoints = [];\n        const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        svg.setAttribute(\"width\", modalContent.clientWidth);\n        svg.setAttribute(\"height\", modalContent.clientHeight);\n        svg.style.position = \"absolute\";\n        svg.style.top = \"0\";\n        svg.style.left = \"0\";\n        svg.style.zIndex = \"10020\";\n        svg.style.width = \"100%\";\n        svg.style.height = \"100%\";\n        modalContent.appendChild(svg);\n        const innerCircles = [];\n        const lines = [];\n        for (let i = 0; i < this._points.length; i++) {\n          const point = this._points[i];\n          const x = point.x;\n          const y = point.y;\n          const relativeX = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.canvasX(x, guideAreaRect, imageData, radius);\n          const relativeY = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.canvasY(y, guideAreaRect, imageData, radius);\n          affinePoints.push({\n            x: relativeX,\n            y: relativeY\n          });\n          const pointDiv = document.createElement(\"div\");\n          pointDiv.className = \"point-div point-div\" + (i + 1);\n          pointDiv.style.position = \"absolute\";\n          pointDiv.style.width = \"25px\";\n          pointDiv.style.height = \"25px\";\n          pointDiv.style.backgroundColor = \"rgb(52 152 219 / 28%)\";\n          pointDiv.style.borderRadius = \"50%\";\n          pointDiv.style.zIndex = \"10040\";\n          pointDiv.style.border = \"2px solid var(--line-border-fill)\";\n          pointDiv.style.left = \"\".concat(relativeX, \"px\");\n          pointDiv.style.top = \"\".concat(relativeY, \"px\");\n          const innerCircle = document.createElement(\"div\");\n          innerCircle.style.position = \"absolute\";\n          innerCircle.style.width = \"4px\";\n          innerCircle.style.height = \"4px\";\n          innerCircle.style.backgroundColor = \"#3498db\";\n          innerCircle.style.borderRadius = \"50%\";\n\n          // Adjusting innerCircle position to center it within pointDiv\n          innerCircle.style.left = \"50%\";\n          innerCircle.style.top = \"50%\";\n          innerCircle.style.transform = \"translate(-50%, -50%)\";\n\n          // pointDiv.appendChild(innerCircle);\n          modalContent.appendChild(pointDiv);\n          innerCircles.push({\n            x: relativeX + 12.5,\n            // Offset to the center of pointDiv\n            y: relativeY + 12.5,\n            div: pointDiv // Store the pointDiv reference\n          });\n\n          // 터치 이벤트 등록\n          pointDiv.addEventListener(\"touchstart\", _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.handleTouchStart(i, pointDiv, affinePoints, x, y), {\n            passive: true\n          });\n          pointDiv.addEventListener(\"touchmove\", _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.handleTouchMove(pointDiv, affinePoints, innerCircles, lines), {\n            passive: true\n          });\n          pointDiv.addEventListener(\"touchend\", _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.handleTouchEnd, {\n            passive: true\n          });\n        }\n        for (let i = 0; i < innerCircles.length; i++) {\n          const start = innerCircles[i];\n          const end = innerCircles[(i + 1) % innerCircles.length]; // Connect the last point to the first point\n          const line = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.createLine(start.x, start.y, end.x, end.y);\n          lines.push(line);\n          svg.appendChild(line);\n        }\n        const containerId = this._cameraOptions.containerId;\n        const container = document.querySelector(containerId);\n        const pointerBtn = document.createElement(\"button\");\n        pointerBtn.id = \"pointerBtn\";\n        pointerBtn.setAttribute(\"class\", \"cropButton\");\n        pointerBtn.innerText = \"SAVE\";\n        container.appendChild(pointerBtn);\n        pointerBtn.style.display = \"block\";\n        pointerBtn.onclick = () => this.handlePointerBtnClick(affinePoints, guideAreaRect, imageData, radius, eventDetail, resolve, pointerBtn);\n      } else {\n        const result = null;\n        resolve(result);\n      }\n    });\n  }\n  async handlePointerBtnClick(affinePoints, guideAreaRect, imageData, radius, eventDetail, resolve, pointerBtn) {\n    let originalPoints = [];\n    for (let i = 0; i < affinePoints.length; i++) {\n      const affinePoint = affinePoints[i];\n      const originalX = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.reverseCanvasX(affinePoint.x, guideAreaRect, imageData, radius);\n      const originalY = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.reverseCanvasY(affinePoint.y, guideAreaRect, imageData, radius);\n      originalPoints.push({\n        x: originalX,\n        y: originalY\n      });\n    }\n    const sortedPoints = _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.sortPoints(originalPoints);\n    const result = this._DocsAffine.getAffine(imageData, imageData.width, imageData.height, sortedPoints);\n    resolve(result);\n    const base64Data = result.resultJSON.base64image;\n    if (eventDetail) {\n      eventDetail.base64Data = base64Data;\n    } else {\n      console.error(\"eventDetail is undefined\");\n    }\n    pointerBtn.style.display = \"none\";\n  }\n  async processOCRResult(result, eventDetail, totalCount, currentCount, imageData, validCheckDt, rtcToken, resultCode, detectTime) {\n    if (!result && this._ocrType !== 16) {\n      console.warn(\"result 없음\");\n      if (currentCount >= totalCount) {\n        eventDetail.success = false;\n        return _constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.RESULT;\n      }\n    }\n\n    // currentCount가 totalCount에 도달했을 때 처리 - 마지막 시도\n    if (currentCount >= totalCount) {\n      // this._webCamera.stop();\n      eventDetail.detectTime = detectTime;\n      eventDetail.validCheckDt = validCheckDt;\n      eventDetail.rtcToken = rtcToken;\n      // OCR 결과 설정\n      if (this._ocrType == 16) {\n        eventDetail.ocrResult = result || resultCode;\n      } else {\n        eventDetail.ocrResult = result;\n      }\n\n      // 성공 여부 판단\n      const isSuccess = this._ocrType === 16 && eventDetail.ocrResult.resultJSON.resultCode == \"0000\" || this._ocrType !== 16 && eventDetail.ocrResult.resultJSON.resultCode == \"0000\";\n      eventDetail.success = isSuccess;\n\n      // 특정 OCR 타입이나 재시도 경우에 대한 진행 상황 반환\n      // if (this._ocrType === 7 || this._iseDetectRetry) {\n      //   return KOI_OCR_EVENT.PROGRESS;\n      // }\n\n      return _constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.RESULT;\n    }\n\n    // result가 존재하고, 정상 처리된 경우\n    // if (result) {\n    if (result && result.resultJSON && result.resultJSON.resultCode == \"0000\") {\n      eventDetail.ocrResult = result;\n      eventDetail.detectTime = detectTime;\n      // this._webCamera.stop();\n      eventDetail.success = true;\n      if (result.resultJSON.formResult && result.resultJSON.formResult.cropImage) {\n        eventDetail.base64Data = result.resultJSON.formResult.cropImage;\n      }\n      return _constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.RESULT;\n    } else {\n      if (result && result.resultJSON.resultCode == \"1004\") {\n        // this._webCamera.stop();\n        eventDetail.detectTime = detectTime;\n        eventDetail.validCheckDt = validCheckDt;\n        eventDetail.rtcToken = rtcToken;\n        eventDetail.ocrResult = result;\n        const isSuccess = this._ocrType === 16 && eventDetail.ocrResult.resultJSON.resultCode == \"0000\" || this._ocrType !== 16 && eventDetail.ocrResult.resultJSON.resultCode == \"0000\";\n        eventDetail.success = isSuccess;\n        return _constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.RESULT;\n      }\n    }\n\n    // resultCode가 존재하고 정상적인 결과일 때 처리 - 문서 crop\n    if (resultCode.resultJSON.resultCode == \"0000\" && this._ocrType == 16) {\n      eventDetail.ocrResult = result || resultCode;\n      eventDetail.detectTime = detectTime;\n      eventDetail.validCheckDt = validCheckDt;\n      eventDetail.rtcToken = rtcToken;\n      eventDetail.success = true;\n      return _constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.RESULT;\n    }\n    // }\n    // 그 외의 경우 OCR 진행 중 이벤트는 따로 처리할 수 있도록 주석 처리\n    // return KOI_OCR_EVENT.PROGRESS;\n  }\n  async runCamera() {\n    if (this.useWebCamera) {\n      this._stopOcr = false; // Reset the flag before starting OCR\n      this._webCamera.start(); // Pass the flag to stop OCR\n      this._isResultDispatched = false;\n      this._isProcessing = false;\n      // this.dispatchEvent(new Event(KOI_OCR_EVENT.CAMERA_STARTED));\n      // return KOI_OCR_EVENT.CAMERA_STARTED;\n    } else {\n      throw new Error(\"WebCamera disabled.\");\n    }\n  }\n\n  // startCamera() {\n  //   if (this.useWebCamera) {\n  //     this._webCamera.start();\n  //   }\n  // }\n\n  stopCamera() {\n    if (this.useWebCamera) {\n      this._webCamera.stop();\n    } else {\n      throw new Error(\"WebCamera disabled.\");\n    }\n  }\n  async stopWorker() {\n    if (this._wasmWorker) {\n      this._wasmWorker.terminate(); // 워커 종료\n      // this._wasmWorker = null; // 워커 참조를 null로 설정\n    }\n  }\n  dispatchReadyEvent() {\n    this.dispatchEvent(new Event(_constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.READY));\n  }\n  dispatchCameraEvent() {\n    this.dispatchEvent(new Event(_constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.CAMERA_STARTED));\n  }\n  dispatchCaptureEvent() {\n    this.dispatchEvent(new Event(_constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.CAPTURE));\n  }\n  dispatchResultEvent(e) {\n    // this.dispatchEvent(new CustomEvent(KOI_OCR_EVENT.RESULT));\n    const event = new CustomEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.KOI_OCR_EVENT.RESULT, {\n      detail: e // cropData에 원하는 데이터를 포함할 수 있음\n      // imageData: imageData,\n    });\n    this.dispatchEvent(event);\n  }\n  async startWasmWorker(ocrType) {\n    // 새 워커 인스턴스를 생성\n    this._wasmWorker = new Worker(\"js/koiOcr/wasmWorker.js\");\n\n    // 현재 페이지 URL을 워커로 전달\n    const getInfo = window.location.href;\n    this._wasmWorker.postMessage({\n      type: \"getInfo\",\n      info: getInfo\n    });\n\n    // OCR 타입을 워커로 전달하여 초기화 요청\n    this._wasmWorker.postMessage({\n      type: \"init\",\n      ocrType: ocrType\n    });\n\n    // 워커의 초기화 결과를 기다림\n    const loadModelResult = await new Promise(resolve => {\n      this._wasmWorker.onmessage = e => {\n        if (e.data.type === \"initComplete\") {\n          // 초기화 성공 시 결과 반환\n          resolve(e.data.result);\n        } else if (e.data.type === \"initFailed\") {\n          // 초기화 실패 시 결과 반환\n          resolve(e.data.result);\n        }\n      };\n    });\n    return loadModelResult;\n  }\n  async changeOcrType(ocrType) {\n    if (ocrType == undefined) {\n      return;\n    }\n    this._ocrType = null;\n    if (this._ocrType == ocrType) {\n      return;\n    }\n    const options = this._options;\n    let loadModelResult = 1;\n    if (this._options.useWasmOcr) {\n      if (ocrType == 2) {\n        const {\n          DocsAffine\n        } = await __webpack_require__.e(/*! import() */ \"public_js_koiOcr_affineProcessor_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./affineProcessor.js */ \"./public/js/koiOcr/affineProcessor.js\"));\n        this._DocsAffine = new DocsAffine();\n        loadModelResult = await this._DocsAffine.loadModel({\n          wasmDirectory: \"./js/affine/\"\n        });\n        this._wasmWorker = new Worker(\"js/koiOcr/wasmWorker.js\"); // 워커 띄울때 url 전달\n        const getInfo = window.location.href;\n        this._wasmWorker.postMessage({\n          type: \"getInfo\",\n          info: getInfo\n        });\n        this._wasmWorker.postMessage({\n          type: \"init\",\n          ocrType: ocrType\n        });\n        loadModelResult = await new Promise(resolve => {\n          this._wasmWorker.onmessage = e => {\n            if (e.data.type == \"initComplete\") {\n              resolve(e.data.result);\n            } else if (e.data.type == \"initFailed\") {\n              resolve(e.data.result);\n            }\n          };\n        });\n        if (loadModelResult == 1) {\n          if (this.useWebCamera) {\n            await this._webCamera.changeOcrType(ocrType);\n          }\n        } else {\n          const error = {\n            code: loadModelResult,\n            message: _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage(loadModelResult)\n          };\n          throw new Error(JSON.stringify(error));\n        }\n      } else if (ocrType == 1 && !this._useDetect && !this._IdCardOCRProcessor) {\n        const {\n          IdCardOCRProcessor\n        } = await __webpack_require__.e(/*! import() */ \"public_js_koiOcr_IdCardOcr_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./IdCardOcr.js */ \"./public/js/koiOcr/IdCardOcr.js\"));\n        this._IdCardOCRProcessor = new IdCardOCRProcessor();\n        loadModelResult = await this._IdCardOCRProcessor.loadModel({\n          wasmDirectory: \"./js/idcard/\"\n        });\n        if (loadModelResult == 1) {\n          if (this.useWebCamera) {\n            await this._webCamera.changeOcrType(ocrType);\n          }\n        } else {\n          this._IdCardOCRProcessor.unload();\n          this._IdCardOCRProcessor = null;\n        }\n      } else if (ocrType == 4 && !this._Barcode) {\n        const {\n          Barcode\n        } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_path-browserify_index_js\"), __webpack_require__.e(\"public_js_koiOcr_barcodeProcessor_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./barcodeProcessor.js */ \"./public/js/koiOcr/barcodeProcessor.js\"));\n        this._Barcode = new Barcode();\n        loadModelResult = await this._Barcode.initialize({\n          wasmDirectory: \"./js/barcode/\"\n        });\n        if (loadModelResult == 1) {\n          if (this.useWebCamera) {\n            await this._webCamera.changeOcrType(ocrType);\n          }\n        } else {\n          this._Barcode = null;\n        }\n      } else if ((ocrType == 7 || ocrType == 16) && !this._DocsAffine) {\n        const {\n          DocsAffine\n        } = await __webpack_require__.e(/*! import() */ \"public_js_koiOcr_affineProcessor_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./affineProcessor.js */ \"./public/js/koiOcr/affineProcessor.js\"));\n        this._DocsAffine = new DocsAffine();\n        loadModelResult = await this._DocsAffine.loadModel({\n          wasmDirectory: \"./js/affine/\"\n          // wasmDirectory: \"/affine/\", // demo\n        });\n        if (loadModelResult == 1) {\n          if (this.useWebCamera) {\n            await this._webCamera.changeOcrType(ocrType);\n          }\n        } else {\n          this._DocsAffine = null;\n        }\n      }\n    } else {\n      if (this.useWebCamera) {\n        await this._webCamera.changeOcrType(ocrType);\n      }\n    }\n    if (this.useWebCamera && ocrType == 16) {\n      await this._webCamera.changeOcrType(ocrType);\n    }\n    if (loadModelResult != 1) {\n      const error = {\n        code: loadModelResult,\n        message: _koiutils_js__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage(loadModelResult)\n      };\n      throw new Error(JSON.stringify(error));\n    }\n    this._ocrType = ocrType;\n  }\n}\n\n\n//# sourceURL=webpack://koiOcr/./public/js/koiOcr/koiOcr.js?");

/***/ }),

/***/ "./public/js/koiOcr/koiutils.js":
/*!**************************************!*\
  !*** ./public/js/koiOcr/koiutils.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64toBlob: () => (/* binding */ base64toBlob),\n/* harmony export */   canvasX: () => (/* binding */ canvasX),\n/* harmony export */   canvasY: () => (/* binding */ canvasY),\n/* harmony export */   convertImageDataToBase64: () => (/* binding */ convertImageDataToBase64),\n/* harmony export */   createLine: () => (/* binding */ createLine),\n/* harmony export */   generateFileName: () => (/* binding */ generateFileName),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   handleTouchEnd: () => (/* binding */ handleTouchEnd),\n/* harmony export */   handleTouchMove: () => (/* binding */ handleTouchMove),\n/* harmony export */   handleTouchStart: () => (/* binding */ handleTouchStart),\n/* harmony export */   reverseCanvasX: () => (/* binding */ reverseCanvasX),\n/* harmony export */   reverseCanvasY: () => (/* binding */ reverseCanvasY),\n/* harmony export */   sortPoints: () => (/* binding */ sortPoints),\n/* harmony export */   updateLines: () => (/* binding */ updateLines)\n/* harmony export */ });\nlet startX, startY;\nfunction convertImageDataToBase64(imageData) {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL(\"image/jpeg\", 0.9).split(\",\")[1];\n}\nfunction canvasX(clientX, guideAreaRect, imageData, radius) {\n  var bound = guideAreaRect;\n  return Math.round(clientX * (bound.width / imageData.width) - radius - 2);\n}\nfunction canvasY(clientY, guideAreaRect, imageData, radius) {\n  var bound = guideAreaRect;\n  return Math.round(clientY * (bound.height / imageData.height) - radius - 2);\n}\nfunction reverseCanvasX(relativeX, guideAreaRect, imageData, radius) {\n  var bound = guideAreaRect;\n  return Math.round((relativeX + radius + 2) / (bound.width / imageData.width));\n}\nfunction reverseCanvasY(relativeY, guideAreaRect, imageData, radius) {\n  var bound = guideAreaRect;\n  return Math.round((relativeY + radius + 2) / (bound.height / imageData.height));\n}\nfunction createLine(x1, y1, x2, y2) {\n  const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n  line.setAttribute(\"x1\", x1);\n  line.setAttribute(\"y1\", y1);\n  line.setAttribute(\"x2\", x2);\n  line.setAttribute(\"y2\", y2);\n  line.setAttribute(\"stroke\", \"#3498db\");\n  line.setAttribute(\"stroke-width\", \"2\");\n  return line;\n}\nfunction updateLines(innerCircles, lines) {\n  for (let i = 0; i < lines.length; i++) {\n    const start = innerCircles[i];\n    const end = innerCircles[(i + 1) % innerCircles.length];\n    lines[i].setAttribute(\"x1\", start.x);\n    lines[i].setAttribute(\"y1\", start.y);\n    lines[i].setAttribute(\"x2\", end.x);\n    lines[i].setAttribute(\"y2\", end.y);\n  }\n}\n\n// 터치 시작 처리 함수\nfunction handleTouchStart(index, pointDiv, affinePoints, x, y) {\n  return function (event) {\n    startX = event.touches[0].clientX - parseInt(pointDiv.style.left);\n    startY = event.touches[0].clientY - parseInt(pointDiv.style.top);\n\n    // 현재 좌표 기록\n    affinePoints[index] = {\n      x: x,\n      y: y\n    };\n\n    // 다음 터치 핸들러에서 참조할 수 있도록 반환\n    return {\n      startX,\n      startY\n    };\n  };\n}\n\n// 터치 이동 처리 함수\nfunction handleTouchMove(pointDiv, affinePoints, innerCircles, lines) {\n  return function (event) {\n    const touchX = event.touches[0].clientX;\n    const touchY = event.touches[0].clientY;\n\n    // 현재 터치 위치로 점 이동\n    pointDiv.style.left = touchX - startX + \"px\";\n    pointDiv.style.top = touchY - startY + \"px\";\n\n    // 움직인 좌표 저장\n    const movedX = parseInt(pointDiv.style.left); // 점의 중심으로 보정\n    const movedY = parseInt(pointDiv.style.top); // 점의 중심으로 보정\n\n    const index = parseInt(pointDiv.className.split(\" \")[1].slice(-1)); // class 이름에서 인덱스 추출\n\n    affinePoints[index - 1] = {\n      x: movedX,\n      y: movedY\n    };\n    innerCircles[index - 1].x = movedX + 12.5; // Update the center position\n    innerCircles[index - 1].y = movedY + 12.5;\n    updateLines(innerCircles, lines);\n  };\n}\n\n// 터치 종료 처리 함수\nfunction handleTouchEnd(event) {\n  // 터치 종료 시 필요한 작업 수행\n  // console.log(\"affinePoints: \", affinePoints);\n}\nfunction sortPoints(originalPoints) {\n  // 배열의 길이가 4가 아니면 예외 처리\n  if (originalPoints.length !== 4) {\n    throw new Error(\"Invalid number of points. Expected 4 points.\");\n  }\n  let sorted = false;\n  while (!sorted) {\n    sorted = true; // 초기에는 정렬되었다고 가정\n\n    // 첫 번째와 두 번째 배열의 x 좌표 비교 후 순서 변경\n    if (originalPoints[0].x > originalPoints[1].x) {\n      [originalPoints[0], originalPoints[1]] = [originalPoints[1], originalPoints[0]];\n      sorted = false; // 정렬이 발생했으므로 다시 확인 필요\n    }\n\n    // 세 번째와 네 번째 배열의 x 좌표 비교 후 순서 변경\n    if (originalPoints[3].x > originalPoints[2].x) {\n      [originalPoints[2], originalPoints[3]] = [originalPoints[3], originalPoints[2]];\n      sorted = false; // 정렬이 발생했으므로 다시 확인 필요\n    }\n\n    // 추가 조건: 첫 번째 배열의 y 좌표가 네 번째 배열의 y 좌표보다 크면 순서 변경\n    if (originalPoints[0].y > originalPoints[3].y) {\n      [originalPoints[0], originalPoints[3]] = [originalPoints[3], originalPoints[0]];\n      sorted = false; // 정렬이 발생했으므로 다시 확인 필요\n    }\n\n    // 추가 조건: 두 번째 배열의 y 좌표가 세 번째 배열의 y 좌표보다 크면 순서 변경\n    if (originalPoints[1].y > originalPoints[2].y) {\n      [originalPoints[1], originalPoints[2]] = [originalPoints[2], originalPoints[1]];\n      sorted = false; // 정렬이 발생했으므로 다시 확인 필요\n    }\n\n    // 추가 조건: 첫 번째 배열의 y 좌표가 세 번째 배열의 y 좌표보다 크면 순서 변경\n    if (originalPoints[0].y > originalPoints[2].y) {\n      [originalPoints[0], originalPoints[1], originalPoints[2], originalPoints[3]] = [originalPoints[1], originalPoints[2], originalPoints[3], originalPoints[0]];\n      sorted = false; // 정렬이 발생했으므로 다시 확인 필요\n    }\n  }\n\n  // 정렬된 좌표 배열을 반환합니다.\n  return originalPoints;\n}\n\n// 토큰&라이선스 체크 결과 처리 함수\nfunction getErrorMessage(tokenResult) {\n  switch (tokenResult) {\n    case 1:\n      return \"Loading Success.\";\n    case -1:\n      return \"Token authentication failed. Please check the token.\";\n    case -2:\n      return \"License authentication error. Please check your license.\";\n    case -3:\n      return \"The model license has expired. Please check the license.\";\n    default:\n      return \"Error initializing KoiOcr.\";\n  }\n}\nfunction generateFileName() {\n  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"rtc_\";\n  let extension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \".jpg\";\n  const currentDate = new Date();\n  const year = currentDate.getFullYear();\n  const month = (\"0\" + (currentDate.getMonth() + 1)).slice(-2); // 월은 0부터 시작하므로 +1\n  const day = (\"0\" + currentDate.getDate()).slice(-2);\n  const hours = (\"0\" + currentDate.getHours()).slice(-2);\n  const minutes = (\"0\" + currentDate.getMinutes()).slice(-2);\n  const seconds = (\"0\" + currentDate.getSeconds()).slice(-2);\n\n  // 파일 이름 형식: prefix + 년월일시분초 + 확장자\n  return \"\".concat(prefix).concat(year).concat(month).concat(day).concat(hours).concat(minutes).concat(seconds).concat(extension);\n}\nconst base64toBlob = (base64Data, mimeString) => {\n  var byteString = atob(base64Data);\n  var ab = new ArrayBuffer(byteString.length);\n  var ia = new Uint8Array(ab);\n  for (var i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n  return new Blob([ab], {\n    type: mimeString\n  });\n};\n\n//# sourceURL=webpack://koiOcr/./public/js/koiOcr/koiutils.js?");

/***/ }),

/***/ "./public/js/koiOcr/webCamera.js":
/*!***************************************!*\
  !*** ./public/js/koiOcr/webCamera.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebCamera)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./public/js/constants.js\");\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// loadCSS(\"css/web.css\");\nconst vh = window.innerHeight * 0.01;\ndocument.documentElement.style.setProperty(\"--vh\", \"\".concat(vh, \"px\"));\ndocument.documentElement.style.backgroundColor = \"rgba(255, 255, 255, 1)\";\n\nclass WebCamera extends EventTarget {\n  constructor() {\n    super();\n    _defineProperty(this, \"_md\", void 0);\n    _defineProperty(this, \"_container\", void 0);\n    _defineProperty(this, \"_videoWrapper\", void 0);\n    _defineProperty(this, \"_videoRef\", void 0);\n    _defineProperty(this, \"_mediaStream\", void 0);\n    _defineProperty(this, \"_canvasRef\", void 0);\n    _defineProperty(this, \"_guideArea\", void 0);\n    _defineProperty(this, \"_letterboxTop\", void 0);\n    _defineProperty(this, \"_letterboxBottom\", void 0);\n    _defineProperty(this, \"_uncoveredArea\", void 0);\n    _defineProperty(this, \"_video\", \"video\");\n    _defineProperty(this, \"_canvas\", \"canvas\");\n    _defineProperty(this, \"_ocrType\", _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.IDCARD);\n    _defineProperty(this, \"_pictureWidth\", window.innerWidth);\n    _defineProperty(this, \"_pictureHeight\", window.innerHeight);\n    _defineProperty(this, \"_vertical\", void 0);\n    _defineProperty(this, \"_useCapOcr\", void 0);\n    _defineProperty(this, \"_a\", false);\n    _defineProperty(this, \"_currentCaptueCount\", void 0);\n    _defineProperty(this, \"_captureInProgress\", false);\n    _defineProperty(this, \"_detectInProgress\", false);\n    _defineProperty(this, \"_isStartInProgress\", false);\n    _defineProperty(this, \"_IdDetectOCR\", void 0);\n    _defineProperty(this, \"_isIpad\", void 0);\n    _defineProperty(this, \"_isIOS\", void 0);\n    _defineProperty(this, \"_isFireFox\", false);\n    _defineProperty(this, \"_isSwapWH\", false);\n    _defineProperty(this, \"_workType\", void 0);\n    _defineProperty(this, \"_title\", void 0);\n    _defineProperty(this, \"_detectRqCount\", 0);\n    _defineProperty(this, \"_key\", void 0);\n    _defineProperty(this, \"_initUseCapOcr\", void 0);\n    _defineProperty(this, \"_useCapOcrFlag\", false);\n    _defineProperty(this, \"_preOcrType\", void 0);\n    _defineProperty(this, \"_orientationChangeButton\", void 0);\n    _defineProperty(this, \"_isReversed\", false);\n    _defineProperty(this, \"_uploadImg\", null);\n    _defineProperty(this, \"_guideMessage\", null);\n    // _shutterSound = null;\n    _defineProperty(this, \"_emitCaptureEventInProgress\", false);\n    _defineProperty(this, \"_successfulDetectionCalled\", false);\n    // 플래그 추가\n    _defineProperty(this, \"_link\", void 0);\n    _defineProperty(this, \"_previousGuideMessage\", null);\n    _defineProperty(this, \"_previousMessage\", null);\n    this._md = new MobileDetect(window.navigator.userAgent);\n    this.captureStopped = false;\n    this.moduleLoaded = false;\n    this._isIpad = /Macintosh|iPad/i.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 1;\n    this._isIOS = /Macintosh|iPad|iPhone|iPod/i.test(navigator.userAgent);\n    if (this._isIOS) {\n      var _exec;\n      let iosVersion = ((_exec = /(Macintosh|iPad|iPhone|iPod) OS ([1-9]*)/g.exec(window.navigator.userAgent)) === null || _exec === void 0 ? void 0 : _exec[2]) || 0;\n      iosVersion = String(iosVersion);\n      this._isSwapWH = iosVersion.startsWith(\"16\");\n    }\n  }\n  get md() {\n    return this._md;\n  }\n  isLandscape() {\n    if (screen.orientation && screen.orientation.type) {\n      return screen.orientation.type.startsWith(\"landscape\");\n    } else if (typeof window.orientation !== \"undefined\") {\n      // Note: window.orientation is deprecated, use with caution\n      return Math.abs(window.orientation) == 90; // 90 또는 -90이면 가로 모드\n    } else {\n      console.warn(\"Unable to determine orientation\");\n      return false;\n    }\n  }\n  get pictureWidth() {\n    return this._pictureWidth;\n  }\n  set pictureWidth(value) {\n    //값이 0으로 넘어오는 경우가 있음. 실제 대입하는 값은 0이 아닌데..\n    if (value > 0) {\n      this._pictureWidth = value;\n    }\n  }\n  get pictureHeight() {\n    return this._pictureHeight;\n  }\n  set pictureHeight(value) {\n    if (value > 0) {\n      this._pictureHeight = value;\n    }\n  }\n  async setOptions(options) {\n    this._options = options;\n    this._useCapOcr = this._options.useCapOcr;\n    this._initUseCapOcr = this._useCapOcr;\n    this._takePhoto = this._options.takePhoto;\n    try {\n      // await navigator.mediaDevices.getUserMedia({ video: true });\n    } catch (err) {\n      console.error(\"Error requesting camera permission:\", err);\n      // Handle permission denied or other errors\n      return;\n    }\n    if (!this._webCameraOptionsSet) {\n      this._webCameraOptionsSet = true;\n      this.initializeComponents(options.containerId);\n    }\n    // if (!this._shutterSound) {\n    //   if (this._options.useDemo) {\n    //     this._shutterSound = new Audio(\"/koiOcr/images/camera_audio.mp3\");\n    //   } else {\n    //     this._shutterSound = new Audio(\"images/camera_audio.mp3\");\n    //   }\n    // }\n  }\n  initializeComponents(containerId) {\n    this.createElement(containerId);\n    this._initEventHandler();\n    this.unload();\n  }\n  async changeOcrType(ocrType) {\n    if (ocrType == undefined) {\n      return;\n    }\n    this._ocrType = null;\n    if (this._ocrType == ocrType) {\n      return;\n    }\n    this._ocrType = ocrType;\n    this._isReversed = false;\n    this._resetUI();\n    if (this._ocrType == 16) {\n      this._options.useDetect = true;\n    }\n    if (this._options.useDetect && !this._detectWorker) {\n      if (this._options.useDemo) {\n        this._detectWorker = new Worker(\"/koiOcr/js/koiOcr/detectWorker.js\"); // demo\n      } else {\n        this._detectWorker = new Worker(\"js/koiOcr/detectWorker.js\");\n      }\n    }\n    await this.loadDetactModule(this._ocrType);\n    this._videoRef.style.objectFit = \"cover\";\n    this._captureInProgress = false;\n    this._detectInProgress = false;\n    this._isStartInProgress = false;\n    this._successfulDetectionCalled = false;\n  }\n  _resetUI() {\n    this._letterboxTop.innerHTML = \"\";\n    this._letterboxBottom.innerHTML = \"\";\n    this._guideArea.innerHTML = \"\";\n    this._guideArea.style.backgroundColor = \"transparent\";\n    this._vertical = null;\n    const containerSize = this._getContainerSize();\n    const videoSize = this._calcVideoSize();\n    const hspace = containerSize.width - videoSize.width;\n    const vspace = containerSize.height - videoSize.height;\n    this._title = document.createElement(\"div\");\n    this._title.id = \"letterTop-title\";\n    this._title.setAttribute(\"role\", \"alert\"); // 스크린 리더가 읽도록 설정\n    this._title.setAttribute(\"aria-live\", \"assertive\");\n    this._title.setAttribute(\"tabindex\", \"0\");\n    this._guideArea.appendChild(this._title);\n    this._title.innerHTML = \"가이드 영역에 맞춰 촬영해주세요.\";\n    const oldContainerDisplay = this._container.display;\n    this._container.display = \"none\";\n    if (hspace > vspace) {\n      this._vertical = 0;\n      this._letterboxTop.style.display = \"inline\";\n      this._letterboxTop.style.top = \"0px\";\n      this._letterboxTop.style.bottom = null;\n      this._letterboxTop.style.left = \"0px\";\n      this._letterboxTop.style.right = null;\n      this._letterboxTop.style.width = \"\".concat(hspace / 2, \"px\");\n      this._letterboxTop.style.height = \"100%\";\n      this._videoWrapper.style.display = \"inline\";\n      this._videoWrapper.style.left = \"\".concat(hspace / 2, \"px\");\n      this._videoWrapper.style.right = null;\n      this._videoWrapper.style.top = \"0px\";\n      this._videoWrapper.style.bottom = null;\n      this._videoWrapper.style.width = \"\".concat(videoSize.width, \"px\");\n      this._videoWrapper.style.height = \"100%\";\n      this._letterboxBottom.style.display = \"inline\";\n      this._letterboxBottom.style.left = null;\n      this._letterboxBottom.style.right = \"0px\";\n      this._letterboxBottom.style.top = \"0px\";\n      this._letterboxBottom.style.bottom = null;\n      this._letterboxBottom.style.width = \"\".concat(hspace / 2, \"px\");\n      this._letterboxBottom.style.height = \"100%\";\n    } else {\n      this._vertical = 1;\n      this._letterboxTop.style.display = \"block\";\n      this._letterboxTop.style.top = \"0px\";\n      this._letterboxTop.style.bottom = null;\n      this._letterboxTop.style.left = \"0px\";\n      this._letterboxTop.style.right = null;\n      this._letterboxTop.style.width = \"100%\";\n      this._letterboxTop.style.height = \"\".concat(vspace / 2, \"px\");\n      this._videoWrapper.style.display = \"block\";\n      this._videoWrapper.style.width = \"100%\";\n      this._videoWrapper.style.left = \"0px\";\n      this._videoWrapper.style.right = null;\n      this._videoWrapper.style.top = \"\".concat(vspace / 2, \"px\");\n      this._videoWrapper.style.bottom = null;\n      this._videoWrapper.style.height = \"\".concat(videoSize.height, \"px\");\n      this._videoRef.style.width = \"\".concat(videoSize.width, \"px\");\n      this._videoRef.style.height = \"\".concat(videoSize.height, \"px\");\n      this._letterboxBottom.style.display = \"block\";\n      this._letterboxBottom.style.width = \"100%\";\n      this._letterboxBottom.style.height = \"\".concat(vspace / 2, \"px\");\n      this._letterboxBottom.style.left = \"0px\";\n      this._letterboxBottom.style.right = null;\n      this._letterboxBottom.style.top = null;\n      this._letterboxBottom.style.bottom = \"0px\";\n    }\n    switch (this._ocrType) {\n      case 1:\n        {\n          this.createIdCardGuide();\n          break;\n        }\n      case 2:\n        {\n          this.createPassportGuide();\n          break;\n        }\n      case 3:\n        {\n          this.createCreaditGuide();\n          break;\n        }\n      case 4:\n        {\n          this.createQrcodeGuide();\n          break;\n        }\n      case 5:\n        {\n          this.createSealCertGuide();\n          break;\n        }\n      case 6:\n        {\n          this.createBizGuide();\n          break;\n        }\n      case 7:\n        {\n          this.createCROP();\n          break;\n        }\n      case 8:\n        {\n          this.createAccountGuide();\n          break;\n        }\n      case 9:\n        {\n          this.createCheckGuide();\n          break;\n        }\n      case 10:\n        {\n          this.createGiroGuide();\n          break;\n        }\n      case 11:\n        {\n          this.createIDfake();\n          break;\n        }\n      case 12:\n        {\n          this.createGiroEPN();\n          break;\n        }\n      case 13:\n        {\n          this.createIDFACE();\n          break;\n        }\n      case 14:\n        {\n          this.createDocsEdge();\n          break;\n        }\n      case 15:\n        {\n          this.createFULLPAGE();\n          break;\n        }\n      case 16:\n        {\n          this.createCROPLIVE();\n          break;\n        }\n    }\n    this._container.display = oldContainerDisplay;\n    this.loadVideoSource();\n  }\n  createIdCardGuide() {\n    // this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n    this._innerGuideBox = document.createElement(\"div\");\n    this._innerGuideBox.style.position = \"absolute\";\n    this._innerGuideBox.style.top = \"0\";\n    this._innerGuideBox.style.left = \"2%\";\n    this._innerGuideBox.style.width = \"96%\";\n    this._innerGuideBox.style.height = \"100%\";\n    this._innerGuideBox.style.padding = \"0\";\n    this._innerGuideBox.style.margin = \"0\";\n    this._innerGuideBox.style.border = \"none\"; // 기존 테두리 제거\n    this._innerGuideBox.style.pointerEvents = \"none\"; // 클릭 이벤트 방지\n    this._innerGuideBox.style.boxSizing = \"border-box\";\n    this._innerGuideBox.className = \"innerGuideBox\";\n    this._guideArea.appendChild(this._innerGuideBox);\n\n    // 꺽쇠 추가 함수\n    const createCorner = (content, position) => {\n      const corner = document.createElement(\"div\");\n      corner.textContent = content; // 꺽쇠 모양\n      corner.style.position = \"absolute\";\n      corner.style.color = \"yellow\"; // 꺽쇠 색상\n      corner.style.fontSize = \"80px\"; // 꺽쇠 크기\n      corner.style.lineHeight = \"1\"; // 줄 높이를 최소화\n      corner.style.pointerEvents = \"none\"; // 클릭 방지\n\n      // 위치에 따라 스타일 지정\n      if (position === \"top-left\") {\n        corner.style.top = \"0\";\n        corner.style.left = \"0\";\n      } else if (position === \"top-right\") {\n        corner.style.top = \"0\";\n        corner.style.right = \"0\";\n      } else if (position === \"bottom-left\") {\n        corner.style.bottom = \"0\";\n        corner.style.left = \"0\";\n      } else if (position === \"bottom-right\") {\n        corner.style.bottom = \"0\";\n        corner.style.right = \"0\";\n      }\n      return corner;\n    };\n\n    // 꺽쇠 요소 추가\n    this._innerGuideBox.appendChild(createCorner(\"⌜\", \"top-left\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌝\", \"top-right\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌞\", \"bottom-left\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌟\", \"bottom-right\"));\n  }\n  createIDfake() {\n    // this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n    this._innerGuideBox = document.createElement(\"div\");\n    this._innerGuideBox.style.position = \"absolute\";\n    this._innerGuideBox.style.top = \"0\";\n    this._innerGuideBox.style.left = \"2%\";\n    this._innerGuideBox.style.width = \"96%\";\n    this._innerGuideBox.style.height = \"100%\";\n    this._innerGuideBox.style.padding = \"0\";\n    this._innerGuideBox.style.margin = \"0\";\n    this._innerGuideBox.style.border = \"none\"; // 기존 테두리 제거\n    this._innerGuideBox.style.pointerEvents = \"none\"; // 클릭 이벤트 방지\n    this._innerGuideBox.style.boxSizing = \"border-box\";\n    this._innerGuideBox.className = \"innerGuideBox\";\n    this._guideArea.appendChild(this._innerGuideBox);\n\n    // 꺽쇠 추가 함수\n    const createCorner = (content, position) => {\n      const corner = document.createElement(\"div\");\n      corner.textContent = content; // 꺽쇠 모양\n      corner.style.position = \"absolute\";\n      corner.style.color = \"yellow\"; // 꺽쇠 색상\n      corner.style.fontSize = \"80px\"; // 꺽쇠 크기\n      corner.style.lineHeight = \"1\"; // 줄 높이를 최소화\n      corner.style.pointerEvents = \"none\"; // 클릭 방지\n      // corner.style.transform = \"translateY(-50%)\";\n\n      // 위치에 따라 스타일 지정\n      if (position === \"top-left\") {\n        corner.style.top = \"0\";\n        corner.style.left = \"0\";\n      } else if (position === \"top-right\") {\n        corner.style.top = \"0\";\n        corner.style.right = \"0\";\n      } else if (position === \"bottom-left\") {\n        corner.style.bottom = \"0\";\n        corner.style.left = \"0\";\n      } else if (position === \"bottom-right\") {\n        corner.style.bottom = \"0\";\n        corner.style.right = \"0\";\n      }\n      return corner;\n    };\n\n    // 꺽쇠 요소 추가\n    this._innerGuideBox.appendChild(createCorner(\"⌜\", \"top-left\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌝\", \"top-right\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌞\", \"bottom-left\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌟\", \"bottom-right\"));\n  }\n  createCreaditGuide() {\n    // this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n    this._innerGuideBox = document.createElement(\"div\");\n    this._innerGuideBox.style.position = \"absolute\";\n    this._innerGuideBox.style.top = \"0\";\n    this._innerGuideBox.style.left = \"2%\";\n    this._innerGuideBox.style.width = \"96%\";\n    this._innerGuideBox.style.height = \"100%\";\n    this._innerGuideBox.style.padding = \"0\";\n    this._innerGuideBox.style.margin = \"0\";\n    this._innerGuideBox.style.border = \"none\"; // 기존 테두리 제거\n    this._innerGuideBox.style.pointerEvents = \"none\"; // 클릭 이벤트 방지\n    this._innerGuideBox.style.boxSizing = \"border-box\";\n    this._innerGuideBox.className = \"innerGuideBox\";\n    this._guideArea.appendChild(this._innerGuideBox);\n\n    // 꺽쇠 추가 함수\n    const createCorner = (content, position) => {\n      const corner = document.createElement(\"div\");\n      corner.textContent = content; // 꺽쇠 모양\n      corner.style.position = \"absolute\";\n      corner.style.color = \"yellow\"; // 꺽쇠 색상\n      corner.style.fontSize = \"80px\"; // 꺽쇠 크기\n      corner.style.lineHeight = \"1\"; // 줄 높이를 최소화\n      corner.style.pointerEvents = \"none\"; // 클릭 방지\n\n      // 위치에 따라 스타일 지정\n      if (position === \"top-left\") {\n        corner.style.top = \"0\";\n        corner.style.left = \"0\";\n      } else if (position === \"top-right\") {\n        corner.style.top = \"0\";\n        corner.style.right = \"0\";\n      } else if (position === \"bottom-left\") {\n        corner.style.bottom = \"0\";\n        corner.style.left = \"0\";\n      } else if (position === \"bottom-right\") {\n        corner.style.bottom = \"0\";\n        corner.style.right = \"0\";\n      }\n      return corner;\n    };\n\n    // 꺽쇠 요소 추가\n    this._innerGuideBox.appendChild(createCorner(\"⌜\", \"top-left\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌝\", \"top-right\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌞\", \"bottom-left\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌟\", \"bottom-right\"));\n    this._orientationChangeButton = document.createElement(\"button\");\n    this._orientationChangeButton.id = \"orientationchange\";\n    this._orientationChangeButton.style.position = \"absolute\";\n    this._orientationChangeButton.style.bottom = \"9%\";\n    this._orientationChangeButton.style.right = \"7%\";\n    this._orientationChangeButton.style.backgroundColor = \"transparent\";\n    this._orientationChangeButton.style.border = \"transparent\";\n\n    // 아이콘 이미지 추가\n    const icon = document.createElement(\"img\");\n    if (this._options.useDemo) {\n      icon.src = \"/koiOcr/images/360-camera_1-removebg.png\"; // 아이콘 경로\n    } else {\n      icon.src = \"images/360-camera_1-removebg.png\"; // 아이콘 경로\n    }\n    icon.alt = \"카메라 전환\";\n    icon.style.width = \"50px\"; // 아이콘 크기\n    icon.style.height = \"50px\";\n    icon.style.backgroundColor = \"transparent\";\n    this._orientationChangeButton.appendChild(icon);\n    this._guideArea.appendChild(this._orientationChangeButton);\n    this._orientationChangeButton.addEventListener(\"click\", () => {\n      this._isReversed = !this._isReversed;\n      this._resetUI();\n    });\n  }\n  createSealCertGuide() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n  }\n  createBizGuide() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n  }\n  createDocsEdge() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n  }\n  createCROP() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n  }\n  createIDFACE() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n  }\n  createFULLPAGE() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n  }\n  createCROPLIVE() {\n    // this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n\n    // 가이드 박스 생성\n    this._innerGuideBox = document.createElement(\"div\");\n    this._innerGuideBox.style.position = \"absolute\";\n    this._innerGuideBox.style.top = \"0\";\n    this._innerGuideBox.style.left = \"2%\";\n    this._innerGuideBox.style.width = \"96%\";\n    this._innerGuideBox.style.height = \"100%\";\n    this._innerGuideBox.style.padding = \"0\";\n    this._innerGuideBox.style.margin = \"0\";\n    this._innerGuideBox.style.border = \"none\"; // 기존 테두리 제거\n    this._innerGuideBox.style.pointerEvents = \"none\"; // 클릭 이벤트 방지\n    this._innerGuideBox.style.boxSizing = \"border-box\";\n    this._innerGuideBox.className = \"innerGuideBox\";\n    this._guideArea.appendChild(this._innerGuideBox);\n\n    // 꺽쇠 추가 함수\n    const createCorner = (content, position) => {\n      const corner = document.createElement(\"div\");\n      corner.textContent = content; // 꺽쇠 모양\n      corner.style.position = \"absolute\";\n      corner.style.color = \"yellow\"; // 꺽쇠 색상\n      corner.style.fontSize = \"80px\"; // 꺽쇠 크기\n      corner.style.lineHeight = \"1\"; // 줄 높이를 최소화\n      corner.style.pointerEvents = \"none\"; // 클릭 방지\n\n      // 위치에 따라 스타일 지정\n      if (position === \"top-left\") {\n        corner.style.top = \"0\";\n        corner.style.left = \"0\";\n      } else if (position === \"top-right\") {\n        corner.style.top = \"0\";\n        corner.style.right = \"0\";\n      } else if (position === \"bottom-left\") {\n        corner.style.bottom = \"0\";\n        corner.style.left = \"0\";\n      } else if (position === \"bottom-right\") {\n        corner.style.bottom = \"0\";\n        corner.style.right = \"0\";\n      }\n      return corner;\n    };\n\n    // 꺽쇠 요소 추가\n    this._innerGuideBox.appendChild(createCorner(\"⌜\", \"top-left\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌝\", \"top-right\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌞\", \"bottom-left\"));\n    this._innerGuideBox.appendChild(createCorner(\"⌟\", \"bottom-right\"));\n    this._orientationChangeButton = document.createElement(\"button\");\n    this._orientationChangeButton.id = \"orientationchange\";\n    this._orientationChangeButton.style.position = \"absolute\";\n    this._orientationChangeButton.style.bottom = \"9%\";\n    this._orientationChangeButton.style.right = \"7%\";\n    this._orientationChangeButton.style.backgroundColor = \"transparent\";\n    this._orientationChangeButton.style.border = \"transparent\";\n\n    // 아이콘 이미지 추가\n    const icon = document.createElement(\"img\");\n    if (this._options.useDemo) {\n      icon.src = \"/koiOcr/images/360-camera_1-removebg.png\"; // 아이콘 경로\n    } else {\n      icon.src = \"images/360-camera_1-removebg.png\"; // 아이콘 경로\n    }\n    icon.alt = \"카메라 전환\";\n    icon.style.width = \"50px\"; // 아이콘 크기\n    icon.style.height = \"50px\";\n    icon.style.backgroundColor = \"transparent\";\n    this._orientationChangeButton.appendChild(icon);\n    this._guideArea.appendChild(this._orientationChangeButton);\n    this._orientationChangeButton.addEventListener(\"click\", () => {\n      this._isReversed = !this._isReversed;\n      this._resetUI();\n    });\n  }\n  createPassportGuide() {\n    const uncoveredAreaTop = document.createElement(\"div\");\n    const uncoveredAreaBottom = document.createElement(\"div\");\n    const mrzFace = document.createElement(\"div\"); // 새로운 div 엘리먼트 생성\n\n    // 새로운 uncovered-area에 클래스를 추가합니다.\n    uncoveredAreaTop.classList.add(\"uncovered-area\", \"uncovered-area-top\");\n    uncoveredAreaBottom.classList.add(\"uncovered-area\", \"uncovered-area-bottom\");\n\n    // 윗 영역 스타일을 수정합니다.\n    uncoveredAreaTop.style.backgroundColor = \"rgba(169, 169, 169, 0.6)\";\n    uncoveredAreaTop.style.width = \"100%\";\n    uncoveredAreaTop.style.height = \"75%\";\n    uncoveredAreaTop.style.top = \"0px\";\n    // uncoveredAreaTop.style.bottom = \"4rem\";\n    uncoveredAreaTop.style.position = \"absolute\";\n    uncoveredAreaTop.style.zIndex = \"10020\";\n    uncoveredAreaBottom.style.border = \"3px solid yellow\";\n    uncoveredAreaBottom.style.width = \"100%\";\n    uncoveredAreaBottom.style.height = \"25%\";\n    uncoveredAreaBottom.style.zIndex = \"10205\";\n    uncoveredAreaBottom.style.position = \"absolute\";\n    uncoveredAreaBottom.style.bottom = \"0px\";\n    mrzFace.classList.add(\"mrz_face\");\n    mrzFace.style.position = \"absolute\";\n    mrzFace.style.width = \"27%\";\n    mrzFace.style.height = \"60%\";\n    mrzFace.style.top = \"30%\";\n    mrzFace.style.left = \"5%\";\n    mrzFace.style.backgroundImage = \"url('images/faceline.png')\";\n    mrzFace.style.backgroundSize = \"cover\";\n    mrzFace.style.backgroundPosition = \"center\";\n    this._letterboxTop.style.backgroundColor = \"rgba(255, 255, 255, 0)\";\n    this._uncoveredAreaTop = uncoveredAreaTop;\n    this._uncoveredAreaBottom = uncoveredAreaBottom;\n    this._guideArea.appendChild(uncoveredAreaTop);\n    this._guideArea.appendChild(uncoveredAreaBottom);\n    uncoveredAreaTop.appendChild(mrzFace);\n  }\n  createDocumentGuide() {}\n  createCornerHighlight(parentElement, character, vertical, horizontal) {\n    const cornerHighlight = document.createElement(\"div\");\n    cornerHighlight.classList.add(\"corner-highlight\");\n    cornerHighlight.style.position = \"absolute\";\n    cornerHighlight.style.width = \"20px\"; // Adjust the size as needed\n    cornerHighlight.style.height = \"20px\"; // Adjust the size as needed\n    cornerHighlight.style.color = \"#fff\"; // White color\n    cornerHighlight.style[vertical] = \"0\";\n    cornerHighlight.style[horizontal] = \"0\";\n    cornerHighlight.style.fontSize = \"60px\"; // Adjust the font size as needed\n    cornerHighlight.textContent = character;\n    parentElement.appendChild(cornerHighlight);\n  }\n  createQrcodeGuide() {\n    // Create a div for QR code area box\n\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n\n    // this._guideArea.setAttribute(\"style\", \"border: 3px solid yellow; z-index:10006;\");\n\n    const qrCodeBox = document.createElement(\"div\");\n    qrCodeBox.classList.add(\"qr-code-box\");\n\n    // Add styles to highlight the corners of the QR code area\n    qrCodeBox.style.position = \"absolute\";\n    qrCodeBox.style.top = \"10%\";\n    qrCodeBox.style.left = \"18%\";\n    qrCodeBox.style.width = \"60%\";\n    qrCodeBox.style.height = \"60%\";\n    qrCodeBox.style.borderRadius = \"10px\"; // Rounded corners\n\n    // Add corner highlights\n    this.createCornerHighlight(qrCodeBox, \"⌜\", \"top\", \"left\");\n    this.createCornerHighlight(qrCodeBox, \"⌝\", \"top\", \"right\");\n    this.createCornerHighlight(qrCodeBox, \"⌞\", \"bottom\", \"left\");\n    this.createCornerHighlight(qrCodeBox, \"⌟\", \"bottom\", \"right\");\n\n    // Add the QR code box to the guideArea\n    this._guideArea.appendChild(qrCodeBox);\n  }\n  createAccountGuide() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n  }\n  createCheckGuide() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n  }\n  createGiroGuide() {\n    this._guideArea.style.border = \"3px solid yellow\";\n    this._guideArea.style.zIndex = \"10006\";\n\n    // const topPadding = document.createElement(\"div\");\n    // topPadding.style.position = \"absolute\";\n    // topPadding.style.top = \"0px\";\n    // topPadding.style.left = \"0px\";\n    // topPadding.style.width = \"100%\";\n    // topPadding.style.height = \"37.5%\";\n    // topPadding.style.backgroundColor = \"rgba(169, 169, 169, 0.6)\";\n\n    // const sampleBox = document.createElement(\"div\");\n    // sampleBox.classList.add(\"fade-out-box\");\n    // sampleBox.style.border = \"2px solid red\";\n    // sampleBox.style.position = \"absolute\";\n    // sampleBox.style.top = \"37.5%\";\n    // sampleBox.style.left = \"0px\";\n    // sampleBox.style.width = \"100%\";\n    // sampleBox.style.height = \"25%\";\n    // sampleBox.style.backgroundImage = \"url('images/giro_sample.jpg')\";\n    // sampleBox.style.backgroundSize = \"contain\";\n    // sampleBox.style.backgroundPosition = \"center\";\n    // sampleBox.style.backgroundRepeat = \"no-repeat\";\n\n    // const guideBox = document.createElement(\"div\");\n    // guideBox.style.border = \"2px solid red\";\n    // guideBox.style.position = \"absolute\";\n    // guideBox.style.top = \"37.5%\";\n    // guideBox.style.left = \"0px\";\n    // guideBox.style.width = \"100%\";\n    // guideBox.style.height = \"25%\";\n    // guideBox.style.backgroundImage = \"url('images/giro_guide.png')\";\n    // guideBox.style.backgroundSize = \"contain\";\n    // guideBox.style.backgroundPosition = \"center\";\n    // guideBox.style.backgroundRepeat = \"no-repeat\";\n\n    // const bottomPadding = document.createElement(\"div\");\n    // bottomPadding.style.position = \"absolute\";\n    // bottomPadding.style.bottom = \"0px\";\n    // bottomPadding.style.left = \"0px\";\n    // bottomPadding.style.width = \"100%\";\n    // bottomPadding.style.height = \"37.5%\";\n    // bottomPadding.style.backgroundColor = \"rgba(169, 169, 169, 0.6)\";\n\n    // this._guideArea.appendChild(topPadding);\n    // this._guideArea.appendChild(bottomPadding);\n    // this._guideArea.appendChild(sampleBox);\n    // this._guideArea.appendChild(guideBox);\n  }\n  createGiroEPN() {\n    // this._guideArea.style.border = \"3px solid yellow\";\n    // this._guideArea.style.zIndex = \"10006\";\n\n    const topPadding = document.createElement(\"div\");\n    topPadding.style.position = \"absolute\";\n    topPadding.style.top = \"0px\";\n    topPadding.style.left = \"0px\";\n    topPadding.style.width = \"100%\";\n    topPadding.style.height = \"42.5%\";\n    topPadding.style.backgroundColor = \"rgba(169, 169, 169, 0.6)\";\n    const guideBox = document.createElement(\"div\");\n    guideBox.style.border = \"2px solid red\";\n    guideBox.style.position = \"absolute\";\n    guideBox.style.top = \"42.5%\";\n    guideBox.style.left = \"40%\";\n    guideBox.style.width = \"60%\";\n    guideBox.style.height = \"15%\";\n    const outguideBox = document.createElement(\"div\");\n    outguideBox.style.position = \"absolute\";\n    // outguideBox.style.border = \"2px solid red\";\n    outguideBox.style.top = \"42.5%\";\n    outguideBox.style.left = \"0px\";\n    outguideBox.style.width = \"40%\";\n    outguideBox.style.height = \"15%\";\n    outguideBox.style.backgroundColor = \"rgba(169, 169, 169, 0.6)\";\n    outguideBox.style.backgroundImage = \"url('images/giro_epn.png')\";\n    outguideBox.style.backgroundSize = \"cover\";\n    outguideBox.style.backgroundPosition = \"center\";\n    outguideBox.style.backgroundRepeat = \"no-repeat\";\n\n    // const rightPadding = document.createElement(\"div\");\n    // rightPadding.style.position = \"absolute\";\n    // rightPadding.style.top = \"42.5%\";\n    // rightPadding.style.left = \"90%\";\n    // rightPadding.style.width = \"10%\";\n    // rightPadding.style.height =\"15%\";\n    // rightPadding.style.backgroundColor = \"rgba(169, 169, 169, 0.6)\";\n\n    const bottomPadding = document.createElement(\"div\");\n    bottomPadding.style.position = \"absolute\";\n    bottomPadding.style.bottom = \"0px\";\n    bottomPadding.style.left = \"0px\";\n    bottomPadding.style.width = \"100%\";\n    bottomPadding.style.height = \"42.5%\";\n    bottomPadding.style.backgroundColor = \"rgba(169, 169, 169, 0.6)\";\n    this._guideArea.appendChild(topPadding);\n    this._guideArea.appendChild(bottomPadding);\n    // this._guideArea.appendChild(sampleBox);\n    this._guideArea.appendChild(outguideBox);\n    this._guideArea.appendChild(guideBox);\n  }\n  getCropImage(ocrType) {\n    this.pictureWidth = this._videoRef.videoWidth;\n    this.pictureHeight = this._videoRef.videoHeight;\n    const swapSize = this._isSwapWH && !this.isLandscape();\n    if (swapSize) {\n      let temp = this.pictureWidth;\n      this.pictureWidth = this.pictureHeight;\n      this.pictureHeight = temp;\n    }\n    const coordinates = this.convertGuideAreaCoordinates(this._guideArea, this._container, this._uncoveredArea, ocrType);\n    let cropX = coordinates.x;\n    let cropY = coordinates.y;\n    let cropWidth = coordinates.width;\n    let cropHeight = coordinates.height;\n    if (swapSize && ocrType == 2) {\n      cropX += 130;\n      cropY -= 60;\n      cropWidth -= 260;\n      cropHeight -= 50;\n    }\n    const canvasRef = this._canvasRef;\n    canvasRef.width = this.pictureWidth;\n    canvasRef.height = this.pictureHeight;\n    const ctx = canvasRef.getContext(\"2d\");\n    ctx.drawImage(this._videoRef, 0, 0, this.pictureWidth, this.pictureHeight);\n\n    //for test 이미지 및 카메라 속성 확인용\n    const printObj = {\n      swapSize: swapSize,\n      videoWidth: this._videoRef.videoWidth,\n      videoHeight: this._videoRef.videoHeight,\n      isIOS: this._isIOS,\n      isIpad: this._isIpad,\n      isLandscape: this.isLandscape(),\n      userAgent: navigator.userAgent,\n      _stream_settings: this._stream_settings\n    };\n\n    // const div = document.createElement(\"div\");\n    // div.style.wordBreak = \"break-word\";\n    // div.innerText = JSON.stringify(printObj);\n    // document.querySelector(\".result-section\").appendChild(div);\n\n    // const img2 = document.createElement(\"img\");\n    // img2.src = canvasRef.toDataURL();\n    // document.querySelector(\".result-section\").appendChild(img2);\n\n    // IDCARD인 경우 리사이징\n    // if (ocrType == 1) {\n    //   const resizedCanvas = document.createElement(\"canvas\");\n    //   const resizedCtx = resizedCanvas.getContext(\"2d\");\n\n    //   const targetWidth = 640;\n    //   const targetHeight = 480;\n\n    //   resizedCanvas.width = targetWidth;\n    //   resizedCanvas.height = targetHeight;\n\n    //   resizedCtx.drawImage(canvasRef, cropX, cropY, cropWidth, cropHeight, 0, 0, targetWidth, targetHeight);\n\n    //   cropWidth = targetWidth;\n    //   cropHeight = targetHeight;\n\n    //   cropWidth = Math.floor(cropWidth);\n    //   cropHeight = Math.floor(cropHeight);\n    //   const imageData = resizedCtx.getImageData(0, 0, cropWidth, cropHeight);\n\n    //   return { imageData, cropWidth, cropHeight };\n    // }\n\n    const croppedCanvas = document.createElement(\"canvas\");\n    const croppedCtx = croppedCanvas.getContext(\"2d\");\n    croppedCanvas.width = cropWidth;\n    croppedCanvas.height = cropHeight;\n    croppedCtx.drawImage(canvasRef, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);\n    cropWidth = Math.floor(cropWidth);\n    cropHeight = Math.floor(cropHeight);\n    const imageData = croppedCtx.getImageData(0, 0, cropWidth, cropHeight);\n\n    // if (!this._a) {\n    const croppedImageData = canvasRef.toDataURL(\"image/png\");\n    this._link = document.createElement(\"a\");\n    this._link.href = croppedImageData;\n    this._link.download = \"getCropImage.png\";\n    // link.click();\n\n    //   const div = document.createElement(\"div\");\n    //   div.style.wordBreak = \"break-word\";\n    //   div.innerText = JSON.stringify(printObj);\n    //   document.querySelector(\".result-section\").appendChild(div);\n\n    //   this._a = true;\n    // }\n\n    return {\n      imageData,\n      cropWidth,\n      cropHeight\n    };\n  }\n  convertGuideAreaCoordinates(guideArea, container, uncoveredArea, ocrType, swapSize) {\n    var containerStyle = window.getComputedStyle(container);\n    var containerRect = container.getBoundingClientRect();\n    var guideAreaRect = guideArea.getBoundingClientRect();\n\n    // guideArea의 현재 좌표를 계산합니다.\n    var left = guideAreaRect.left - containerRect.left;\n    var top = guideAreaRect.top - containerRect.top;\n\n    // 크롭 영역 초기화\n    var cropWidth = 0;\n    var cropHeight = 0;\n    var guideAreaX = 0;\n    var guideAreaY = 0;\n    var fitWidth = this.pictureWidth / guideAreaRect.width <= this.pictureHeight / guideAreaRect.height;\n\n    // 세로가 더 큰 경우에 대한 처리\n    if (fitWidth) {\n      switch (ocrType) {\n        // case OCR_TYPE.IDCARD: //\n        //   cropWidth = this.pictureWidth;\n        //   cropHeight = (this.pictureWidth * guideAreaRect.height) / guideAreaRect.width;\n        //   cropHeight = cropHeight * 0.55;\n        //   cropWidth = cropWidth * 0.68;\n        //   guideAreaY = cropHeight * 0.4;\n        //   guideAreaX = this.pictureWidth * 0.25;\n        //   break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.PASSPORT:\n          //\n          cropWidth = this.pictureWidth;\n          cropHeight = this.pictureWidth * guideAreaRect.height / guideAreaRect.width;\n          guideAreaY = (this.pictureHeight - cropHeight) / 2;\n          guideAreaX = 0;\n          guideAreaY += cropHeight * 3 / 4;\n          cropHeight = cropHeight / 4;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.GIROEPN:\n          //\n          cropWidth = this.pictureWidth;\n          cropHeight = this.pictureWidth * guideAreaRect.height / guideAreaRect.width;\n          cropWidth = cropWidth * 0.6;\n          cropHeight = cropHeight * 0.15;\n          guideAreaY = (this.pictureHeight - cropHeight) / 2;\n          guideAreaX = this.pictureWidth * 0.4;\n          break;\n        // case OCR_TYPE.GIRO: //\n        //   cropWidth = this.pictureWidth;\n        //   cropHeight = (this.pictureWidth * guideAreaRect.height) / guideAreaRect.width;\n        //   cropHeight = cropHeight * (2 / 8);\n\n        //   guideAreaY = (this.pictureHeight - cropHeight) / 2;\n        //   guideAreaX = (this.pictureWidth - cropWidth) / 2;\n        //   break;\n        default:\n          cropWidth = this.pictureWidth;\n          cropHeight = this.pictureWidth * guideAreaRect.height / guideAreaRect.width;\n          guideAreaY = (this.pictureHeight - cropHeight) / 2;\n          guideAreaX = 0;\n          // 다른 OCR_TYPE에 대한 처리 추가\n          break;\n      }\n    } else {\n      switch (ocrType) {\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.PASSPORT:\n          // OCR_TYPE.PASSPORT에 대한 처리 추가\n          cropHeight = this.pictureHeight;\n          cropWidth = this.pictureHeight * guideAreaRect.width / guideAreaRect.height;\n          guideAreaY = 0;\n          guideAreaX = (this.pictureWidth - cropWidth) / 2;\n          guideAreaY += cropHeight * 3 / 4;\n          cropHeight = cropHeight / 4;\n          break;\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.GIROEPN:\n          cropHeight = this.pictureHeight;\n          cropWidth = this.pictureHeight * guideAreaRect.width / guideAreaRect.height;\n          cropWidth = cropWidth * 0.6;\n          // cropWidth = cropWidth * (2 / 8);\n          cropHeight = cropHeight * 0.15;\n          guideAreaY = (this.pictureHeight - cropHeight) / 2;\n          guideAreaX = this.pictureWidth * 0.4;\n          // guideAreaX = this.pictureWidth / 2 - cropWidth / 2;\n          break;\n        // case OCR_TYPE.GIRO: //\n        //   cropHeight = this.pictureHeight;\n        //   cropWidth = (this.pictureHeight * guideAreaRect.width) / guideAreaRect.height;\n        //   cropWidth = cropWidth * (2 / 8);\n\n        //   guideAreaY = (this.pictureHeight - cropHeight) / 2;\n        //   guideAreaX = (this.pictureWidth - cropWidth) / 2;\n        //   break;\n        default:\n          cropHeight = this.pictureHeight;\n          cropWidth = this.pictureHeight * guideAreaRect.width / guideAreaRect.height;\n          guideAreaY = 0;\n          guideAreaX = (this.pictureWidth - cropWidth) / 2;\n          // 다른 OCR_TYPE에 대한 처리 추가\n          break;\n      }\n    }\n    var coordinates = {\n      x: guideAreaX,\n      y: guideAreaY,\n      width: cropWidth,\n      height: cropHeight\n    };\n    return coordinates;\n  }\n  getVideoRatio(ocrType) {\n    let ratio = {\n      width: 4,\n      height: 3\n    }; // 기본 비율\n\n    switch (ocrType) {\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.IDCARD:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.PASSPORT:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.QRCODE:\n        ratio = {\n          width: 4,\n          height: 3\n        };\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.CREDITCARD:\n        ratio = {\n          width: 1,\n          height: 0.65\n        };\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.SEALCERT:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.BIZREGCERT:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.CROP:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.IDFACE:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.FULLPAGE:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.CROPLIVE:\n        ratio = {\n          width: 1,\n          height: 1.4\n        };\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.ACCOUNT:\n        ratio = {\n          width: 2,\n          height: 1\n        };\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.CHECK:\n        ratio = {\n          width: 40,\n          height: 17\n        };\n        break;\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.GIRO:\n      case _constants_js__WEBPACK_IMPORTED_MODULE_0__.OCR_TYPE.GIROEPN:\n        ratio = {\n          width: 13,\n          height: 8\n        };\n        break;\n      default:\n        ratio = {\n          width: 4,\n          height: 3\n        };\n    }\n\n    // 비율 반전 여부에 따라 width와 height 값을 반전\n    if (this._isReversed) {\n      return {\n        width: ratio.height,\n        height: ratio.width\n      };\n    }\n    return ratio;\n  }\n  createElement(containerId) {\n    this._container = document.querySelector(containerId);\n\n    // top or left letter box\n    this._letterboxTop = document.createElement(\"div\");\n    this._letterboxTop.classList.add(\"background\", \"top\");\n    this._letterboxTop.setAttribute(\"style\", \"display: block !important;\");\n    this._container.appendChild(this._letterboxTop);\n\n    // create video wrapper\n    this._videoWrapper = document.createElement(\"div\");\n    this._videoWrapper.classList.add(\"wrapper\");\n    this._videoWrapper.style.position = \"absolute\";\n\n    // video\n    this._videoRef = document.createElement(\"video\");\n    this._videoRef.id = \"kwcVideo\";\n    this._videoRef.classList.add(\"video\");\n    this._videoRef.autoplay = \"autoplay\";\n    this._videoRef.WebKitPlaysInline = true;\n    this._videoRef.setAttribute(\"playsinline\", true);\n    this._videoRef.muted = true;\n    this._videoRef.setAttribute(\"muted\", true);\n    this._videoRef.setAttribute(\"aria-hidden\", \"true\");\n\n    // canvas\n    this._canvasRef = document.createElement(\"canvas\");\n    this._canvasRef.id = \"kwcCanvas\";\n    this._canvasRef.classList.add(\"canvas\");\n    this._canvasRef.setAttribute(\"style\", \"display: none;\");\n\n    // guide\n    this._guideArea = document.createElement(\"div\");\n    this._guideArea.id = \"kwcGuideArea\";\n    this._guideArea.style.position = \"absolute\";\n    this._guideArea.style.width = \"100%\";\n    this._guideArea.style.height = \"100%\";\n\n    // this._orientationChangeButton = document.createElement(\"button\");\n    // this._orientationChangeButton.id = \"orientationchange\";\n    // this._orientationChangeButton.style.position = \"absolute\";\n    // this._orientationChangeButton.style.bottom = \"0\";\n    // this._orientationChangeButton.style.right = \"3%\";\n    // this._orientationChangeButton.textContent = \"카메라 전환\"; // Optional button text\n    // this._guideArea.appendChild(this._orientationChangeButton);\n\n    this._videoWrapper.appendChild(this._videoRef);\n    this._videoWrapper.appendChild(this._canvasRef);\n    this._videoWrapper.appendChild(this._guideArea);\n    this._container.appendChild(this._videoWrapper);\n\n    // bottom or right letter box\n    this._letterboxBottom = document.createElement(\"div\");\n    this._letterboxBottom.classList.add(\"background\", \"bottom\");\n    this._container.appendChild(this._letterboxBottom);\n  }\n  _getContainerSize() {\n    let oldDisplay = null;\n    oldDisplay = this._container.style.display;\n    this._container.style.display = \"block\";\n    // Get the container size\n    const sizeObj = {\n      width: this._container.clientWidth,\n      height: this._container.clientHeight // Use offsetHeight instead of clientHeight\n    };\n    this._container.style.display = oldDisplay;\n    return sizeObj;\n  }\n  _calcVideoSize() {\n    const containerSize = this._getContainerSize();\n    const videoRatio = this.getVideoRatio(this._ocrType);\n    const wl = containerSize.width / videoRatio.width;\n    const hl = containerSize.height / videoRatio.height;\n    const minLength = Math.min(wl, hl);\n    return {\n      width: minLength * videoRatio.width,\n      height: minLength * videoRatio.height\n    };\n  }\n  _initEventHandler() {\n    this._videoRef.addEventListener(\"loadedmetadata\", event => {\n      this.dispatchEvent(new Event(\"webcamready\"));\n    });\n    window.addEventListener(\"beforeunload\", event => {\n      this.unload();\n      this.unloadDetect();\n    });\n    window.addEventListener(\"orientationchange\", event => {\n      this.unload();\n      setTimeout(() => {\n        this._resetUI();\n      }, 300);\n    });\n\n    // this._orientationChangeButton.addEventListener(\"click\", () => {\n    //   this._isReversed = !this._isReversed;\n    //   this._resetUI();\n    // });\n  }\n  async unloadDetect() {\n    if (this._detectWorker) {\n      this._detectWorker.postMessage({\n        type: \"unload\"\n      });\n      const unloadResult = await new Promise(resolve => {\n        this._detectWorker.onmessage = event => {\n          if (event.data.type == \"unloadComplete\") {\n            resolve(true);\n          }\n        };\n      });\n      if (unloadResult) {\n        // console.log(\"Detect module successfully unloaded.\");\n        this._detectWorker.terminate();\n        this._detectWorker = null;\n      }\n    }\n  }\n  async getUsers() {\n    try {\n      const constraints = await this.getConstraints();\n      const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\n      console.log(\"mediaStream: \", mediaStream);\n      // this._mediaStream = mediaStream;\n      return mediaStream;\n    } catch (err) {\n      console.log(\"err: \", err);\n      if (err.name === \"NotAllowedError\") {\n        // 기존 오류 메시지에 추가 설명을 덧붙여 새로운 에러 객체를 생성하여 던지기\n        throw new Error(\"\".concat(err.message, \". \\n\\n\\uCE74\\uBA54\\uB77C \\uC0AC\\uC6A9 \\uAD8C\\uD55C\\uC744 \\uD5C8\\uC6A9\\uD574 \\uC8FC\\uC138\\uC694.\"));\n      } else if (err.name === \"NotReadableError\") {\n        // 'Device in use' 에러에 대한 추가 메시지 처리\n        throw new Error(\"\".concat(err.message, \". \\n\\n\\uB2E4\\uB978 \\uD0ED\\uC5D0\\uC11C \\uCE74\\uBA54\\uB77C\\uB97C \\uC0AC\\uC6A9 \\uC911\\uC785\\uB2C8\\uB2E4.\\n\\uCE74\\uBA54\\uB77C\\uB97C \\uC885\\uB8CC\\uD558\\uACE0 \\uB2E4\\uC2DC \\uC2DC\\uB3C4\\uD558\\uC138\\uC694.\"));\n      } else {\n        throw new Error(\"An error occurred: \".concat(err.message));\n      }\n    }\n  }\n  async loadVideoSource() {\n    try {\n      const mediaStream = await this.getUsers();\n      this._stream_settings = mediaStream.getVideoTracks()[0].getSettings();\n      this._mediaStream = mediaStream;\n      if (\"srcObject\" in this._videoRef) {\n        this._videoRef.srcObject = mediaStream;\n      } else {\n        this._videoRef.src = URL.createObjectURL(mediaStream);\n      }\n    } catch (err) {\n      console.log(err);\n      alert(err);\n      throw err;\n    }\n  }\n  async getConstraints() {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const filteredDevices = devices.filter(v => {\n      return v.kind == \"videoinput\";\n    });\n    for (const device of filteredDevices) {}\n    const deviceId = filteredDevices[filteredDevices.length - 1].deviceId;\n    const constraints = {\n      audio: false,\n      video: {\n        facingMode: {\n          ideal: \"environment\"\n        },\n        zoom: true,\n        focusMode: \"continuous\",\n        width: 1920,\n        height: 1080\n      }\n    };\n    if (/Android/i.test(navigator.userAgent)) {\n      // console.log(\"This is an android device.\");\n      if (filteredDevices.length > 0) {\n        constraints.video.deviceId = filteredDevices[filteredDevices.length - 1].deviceId;\n      }\n    } else if (this._isIOS) {\n      var iOSVersion = this.getiOSVersion();\n      constraints.video.width = 2560;\n      constraints.video.height = 1440;\n    } else {\n      // console.log(\"Etc device : \" + navigator.userAgent);\n      //alert(\"Etc device : \" + navigator.userAgent)\n    }\n    if (navigator.userAgent.includes(\"Firefox\")) {\n      this._isFireFox = true;\n    }\n    return constraints;\n  }\n  getiOSVersion() {\n    var userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    var iOSVersionMatch = userAgent.match(/OS (\\d+_\\d+(_\\d+)?)/i);\n    if (iOSVersionMatch && iOSVersionMatch.length > 1) {\n      return iOSVersionMatch[1].replace(/_/g, \".\");\n    }\n    return null;\n  }\n  unload() {\n    if (this._mediaStream) {\n      this._mediaStream.getTracks().forEach(track => track.stop());\n      this._mediaStream = null;\n      this._videoRef.srcObject = null;\n    }\n  }\n\n  //move To Utils\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  async stop() {\n    this._captureinProgress = false;\n    if (this._detectTimeoutId) {\n      clearTimeout(this._detectTimeoutId);\n      this._detectTimeoutId = null;\n    }\n    if (this._orientationChangeButton) {\n      this._orientationChangeButton.remove(); // DOM에서 버튼 제거\n      this._orientationChangeButton = null; // 참조를 null로 설정하여 메모리 해제\n    }\n  }\n\n  // webCamera 객체의 startFile 메서드\n  async startFile(eventDetail) {\n    const {\n      imageData,\n      imageWidth,\n      imageHeight\n    } = eventDetail;\n    const cropWidth = imageWidth;\n    const cropHeight = imageHeight;\n    // const validCheckDt = true;\n    this._uploadImg = {\n      imageData,\n      cropWidth,\n      cropHeight\n    };\n    this.start();\n  }\n  async start() {\n    this._isStartInProgress = true;\n    try {\n      const options = this._options;\n      // 수동 촬영 모드 처리\n      if (this._useCapOcr == 2 || this._useCapOcr == 3 || this._useCapOcr == 4) {\n        options.rtcMaxRetryCount = 1;\n      }\n      if (options.rtcStartDelay > 0) {\n        await this.delay(options.rtcStartDelay);\n      }\n      this._captureinProgress = true;\n      this._currentCaptueCount = 0;\n      this._detectRqCount = 0;\n      this._key = crypto.randomUUID();\n      if (!this._successfulDetectionCalled) {\n        await this.processCapture(); // 비동기 캡처 시작\n      }\n    } finally {\n      this._isStartInProgress = false; // 플래그 리셋\n      // this._captureinProgress = false;\n    }\n  }\n  async loadDetactModule(workType) {\n    if (this._detectWorker) {\n      if (this._ocrType === 1 || this._ocrType === 3 || this._ocrType === 11 || this._ocrType === 10 || this._ocrType === 16) {\n        try {\n          this._detectWorker.postMessage({\n            type: workType\n          });\n          const initResult = await new Promise(resolve => {\n            this._detectWorker.onmessage = event => {\n              if (event.data.type === \"initComplete\") {\n                resolve(true);\n              } else if (event.data.type === \"initFailed\") {\n                resolve(false);\n              }\n            };\n          });\n          this._useDetect = initResult;\n          this.moduleLoaded = initResult;\n          if (!initResult) {\n            throw new Error(\"WASM module loading failed.\");\n          }\n        } catch (error) {\n          this._useDetect = false;\n          this.moduleLoaded = false;\n          alert(\"Error: \".concat(error.message));\n          console.error(\"WASM module loading error:\", error);\n        }\n      }\n    } else {\n      this._useDetect = false;\n    }\n  }\n  async processCapture() {\n    if (this._detectInProgress || !this._captureinProgress) {\n      console.warn(\"Detection already in progress or capture not active.\");\n      return;\n    }\n    while (this._captureinProgress && this._currentCaptueCount < this._options.rtcMaxRetryCount) {\n      this._currentCaptueCount++;\n      const options = this._options;\n      let cropImageData = null;\n      let validCheckDt = this._currentCaptueCount >= options.rtcMaxRetryCount;\n      let resultCode = null;\n      let successDt = null;\n      console.log(\"총 시도 횟수 : \", options.rtcMaxRetryCount, \", 현재 시도 횟수 : \", this._currentCaptueCount);\n      if (this._useDetect) {\n        const detectionResult = await this.handleDetection(options, validCheckDt);\n        // console.log(\"this._guideMessage: \", this._guideMessage);\n        // this._title.innerHTML = this._guideMessage;\n\n        if (detectionResult) {\n          var _resultCode;\n          cropImageData = detectionResult.cropImageData;\n          resultCode = detectionResult.resultCode;\n          successDt = detectionResult.detectTime;\n          if (this._ocrType === 16 && ((_resultCode = resultCode) === null || _resultCode === void 0 || (_resultCode = _resultCode.resultJSON) === null || _resultCode === void 0 ? void 0 : _resultCode.resultCode) === \"0\") {\n            resultCode.resultJSON.resultCode = \"0000\";\n          }\n          await this.handleSuccessfulDetection(cropImageData, validCheckDt, resultCode, successDt);\n          this._successfulDetectionCalled = true; // 플래그 업데이트\n\n          break;\n        }\n      } else {\n        // this._useDetect가 false일 때\n        cropImageData = this.getCropImage(this._ocrType);\n        resultCode = null;\n        await this.emitCaptureEvent(cropImageData, validCheckDt, resultCode, successDt);\n        break;\n      }\n\n      // delay 후 다시 시도\n      if (this._currentCaptueCount < options.rtcMaxRetryCount) {\n        await this.delay(options.rtcRetryDelay);\n        this.resetDetectionState();\n      }\n    }\n    this._captureinProgress = false; // 모든 시도가 끝났을 경우\n  }\n  resetDetectionState() {\n    // 상태 변수를 초기화합니다.\n    this._detectInProgress = true; // 필요에 따라 초기화\n    this._detectRqCount = 0; // 탐지 요청 수 초기화\n    // 이외의 필요한 상태 변수를 초기화\n  }\n  async handleDetection(options, validCheckDt) {\n    let detectResultCode = 0;\n    let detectMessage = null;\n    let imageData = null;\n    let cropImageData = null;\n    this._detectInProgress = true;\n    let resultCode = null;\n    let detectResults = null;\n    let detectTime = null;\n    this._previousGuideMessage = null;\n    // const detectTimeoutId = this.startDetectionTimer(rtcDetectTime);\n    const rtcDetectTime = options.rtcDetectTime ? options.rtcDetectTime : 10000;\n    const detectTimeoutId = setTimeout(() => {\n      this._detectInProgress = false;\n    }, rtcDetectTime);\n    while (this._captureinProgress && this._detectInProgress) {\n      if (this._useCapOcr == 3) {\n        cropImageData = this._uploadImg;\n        validCheckDt = true;\n        // imageData = cropImageData.data;\n      } else {\n        cropImageData = this.getCropImage(this._ocrType);\n      }\n      imageData = cropImageData.imageData;\n      if (this._ocrType === 10) {\n        await this.handleGiroTypeDetection(imageData, null);\n      }\n      if ([1, 3, 10, 11, 16].includes(this._ocrType)) {\n        detectResults = await this.sendDetectRequest(imageData, validCheckDt);\n        // if (this._ocrType == 16) {\n        resultCode = detectResults.resultCode;\n        detectTime = detectResults.detectTime;\n        // } else {\n        // resultCode = null;\n        // }\n\n        // console.log(\"detectResults: \", detectResults);\n        detectResultCode = this.getDetectResultCode(detectResults);\n        const detectSuccess = detectResults.continuousSuccess;\n        if (this._ocrType == 1 || this._ocrType == 11) {\n          detectMessage = this.updateTitleID(detectResultCode);\n        } else if (this._ocrType == 3) {\n          detectMessage = this.updateTitleCredit(detectResultCode);\n        } else if (this._ocrType == 16) {\n          detectMessage = \"문서를 가이드 영역에 맞춰주세요.\";\n        }\n        this._guideMessage = detectMessage;\n        if (detectMessage !== this._previousGuideMessage) {\n          this._title.innerHTML = this._guideMessage;\n          this._previousGuideMessage = detectMessage;\n        }\n\n        // 탐지 성공\n        if (await this.isDetectSuccessful(detectSuccess)) {\n          if (this._orientationChangeButton) {\n            this._orientationChangeButton.remove(); // DOM에서 버튼 제거\n            this._orientationChangeButton = null; // 참조를 null로 설정하여 메모리 해제\n          }\n          // detectMessage = this.getOcrMessage(this._ocrType);\n          // this._guideMessage = detectMessage;\n\n          this._detectInProgress = false;\n          this._captureInProgress = false;\n          clearTimeout(detectTimeoutId);\n          return {\n            cropImageData: cropImageData,\n            resultCode: resultCode,\n            detectTime: detectTime\n          };\n        } else {\n          // console.log(\"탐지 실패\");\n          // detectMessage = this.handleFailedDetection(detectResultCode);\n          // cropImageData = null;\n          // break;\n        }\n      }\n      // await this.delay(20);\n    }\n    if (this._detectRqCount >= options.rtcMaxRetryCount) {\n      this._detectRqCount = 0;\n    }\n    if (this._currentCaptueCount >= options.rtcMaxRetryCount) {\n      return {\n        cropImageData: cropImageData,\n        resultCode: resultCode,\n        detectTime: detectTime\n      };\n    }\n    return null;\n  }\n  async sendDetectRequest(imageData, validCheckDt) {\n    const startTime = performance.now();\n    this._detectWorker.postMessage({\n      type: \"detect\",\n      imageData,\n      width: imageData.width,\n      height: imageData.height,\n      ocrType: this._ocrType,\n      useCapOcr: this._useCapOcr,\n      validCheckDt: validCheckDt\n    });\n    return new Promise(resolve => {\n      this._detectWorker.onmessage = event => {\n        if (event.data.type === \"detectResult\") {\n          const endTime = performance.now(); // detect 시간 측정 끝\n          const detectTime = endTime - startTime;\n          event.data.detectTime = detectTime;\n          resolve(event.data);\n        }\n      };\n    });\n  }\n  getDetectResultCode(detectResults) {\n    return this._ocrType === 16 ? detectResults.resultCode.resultJSON.resultCode : detectResults.resultCode;\n  }\n  isDetectSuccessful(detectSuccess) {\n    return detectSuccess;\n  }\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  async applyBlinkEffect(element) {\n    element.style.backgroundColor = \"rgba(0, 0, 0, 0.7)\";\n    await this.sleep(50);\n    element.style.backgroundColor = \"rgba(0, 0, 0, 0)\";\n  }\n  getOcrTitleMessage(ocrType) {\n    switch (ocrType) {\n      case 1:\n      case 11:\n        return \"신분증 촬영중입니다.\";\n      case 3:\n        return \"카드 촬영중입니다.\";\n      case 16:\n        return \"문서 촬영중입니다.\";\n      default:\n        return \"촬영중입니다.\";\n    }\n  }\n  async handleSuccessfulDetection(cropImageData, validCheckDt, resultCode, detectTime) {\n    try {\n      this._videoRef.pause();\n      let successImgData = null;\n\n      // Set OCR title message\n      this._title.innerHTML = this.getOcrTitleMessage(this._ocrType);\n\n      // Determine image processing logic\n      if (this._isIOS || this._ocrType == 16 || this._isFireFox) {\n        successImgData = cropImageData;\n        await this.applyBlinkEffect(this._guideArea);\n      } else if (this._takePhoto) {\n        try {\n          const mediaStream = await this.getUsers();\n          const imageCapture = new ImageCapture(mediaStream.getVideoTracks()[0]);\n          const capabilities = await imageCapture.getPhotoCapabilities();\n\n          // const photoSettings = {\n          //   imageHeight: capabilities.imageHeight.max,\n          //   imageWidth: capabilities.imageWidth.max,\n          // };\n\n          const QHD_WIDTH = 2560;\n          const QHD_HEIGHT = 1440;\n          const closestWidth = Math.min(capabilities.imageWidth.max, QHD_WIDTH);\n          const closestHeight = Math.min(capabilities.imageHeight.max, QHD_HEIGHT);\n          const photoSettings = {\n            imageWidth: closestWidth,\n            imageHeight: closestHeight\n          };\n          const startTime = performance.now();\n          const blob = await imageCapture.takePhoto(photoSettings);\n          await this.applyBlinkEffect(this._guideArea);\n          const endTime = performance.now();\n\n          // console.log(\"photoSettings: \", photoSettings);\n\n          // console.log(`takePhoto 처리 시간: ${(endTime - startTime).toFixed(2)} ms`);\n          successImgData = await this.drawImageToCanvasAndGetDataUrl(blob);\n        } catch (error) {\n          console.error(\"Image capture failed. Falling back to cropImageData:\", error);\n          // alert(\"takephoto 실패\");\n          successImgData = cropImageData;\n        }\n      } else {\n        successImgData = cropImageData;\n      }\n\n      // Clear title and emit capture event\n      this._title.innerHTML = \"\";\n      await this.emitCaptureEvent(successImgData, validCheckDt, resultCode, detectTime);\n\n      // Update the title with the success message\n      this._title.innerHTML = this.getOcrMessage(this._ocrType);\n\n      // Additional cleanup\n      this._detectRqCount++;\n      this._detectInProgress = false;\n      if (this._innerGuideBox) {\n        this._innerGuideBox.style.display = \"none\";\n      }\n    } catch (error) {\n      console.error(\"Error:\", error.message, error);\n      alert(\"error: \" + error.message);\n    }\n  }\n  drawImageToCanvasAndGetDataUrl(imageBlob) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(imageBlob);\n      reader.onload = () => {\n        const dataUrl = reader.result;\n        const img = new Image();\n        img.onload = () => {\n          const canvas = document.createElement(\"canvas\");\n          const ctx = canvas.getContext(\"2d\");\n          const targetAspectRatio = img.width > img.height ? 16 / 9 : 9 / 16;\n          const tolerance = 0.05;\n          // 원본 이미지 비율 계산\n          const originalAspectRatio = img.width / img.height;\n          let startX = 0,\n            startY = 0,\n            cutWidth = img.width,\n            cutHeight = img.height;\n\n          // 비율 차이가 허용 범위 내이면 크롭하지 않음\n          if (Math.abs(originalAspectRatio - targetAspectRatio) < tolerance) {\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0);\n          } else {\n            // 비율 차이가 크면 크롭\n            if (originalAspectRatio > targetAspectRatio) {\n              // 너비를 줄여야 함\n              cutWidth = img.height * targetAspectRatio;\n              startX = (img.width - cutWidth) / 2; // 가운데 정렬\n            } else {\n              // 높이를 줄여야 함\n              cutHeight = img.width / targetAspectRatio;\n              startY = (img.height - cutHeight) / 2; // 가운데 정렬\n            }\n            canvas.width = cutWidth;\n            canvas.height = cutHeight;\n            ctx.drawImage(img, startX, startY, cutWidth, cutHeight, 0, 0, cutWidth, cutHeight);\n          }\n          this.pictureWidth = canvas.width;\n          this.pictureHeight = canvas.height;\n          const coordinates = this.convertGuideAreaCoordinates(this._guideArea, this._container, this._uncoveredArea, this._ocrType);\n          let cropX = coordinates.x;\n          let cropY = coordinates.y;\n          let cropWidth = coordinates.width;\n          let cropHeight = coordinates.height;\n          const croppedCanvas = document.createElement(\"canvas\");\n          const croppedCtx = croppedCanvas.getContext(\"2d\");\n          croppedCanvas.width = cropWidth;\n          croppedCanvas.height = cropHeight;\n          croppedCtx.drawImage(canvas, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);\n\n          // const originImageData = croppedCanvas.toDataURL(\"image/png\");\n          // const link2 = document.createElement(\"a\");\n          // link2.href = originImageData;\n          // link2.download = \"takePhoto.png\";\n          // link2.click();\n\n          resolve({\n            imageData: croppedCtx.getImageData(0, 0, croppedCanvas.width, croppedCanvas.height),\n            cropWidth: croppedCanvas.width,\n            cropHeight: croppedCanvas.height\n          });\n        };\n        img.src = dataUrl;\n      };\n      reader.onerror = error => {\n        reject(error);\n      };\n    });\n  }\n  getOcrMessage(ocrType) {\n    switch (ocrType) {\n      case 1:\n        return \"OCR 진행중입니다.\";\n      case 3:\n        return \"OCR 진행중입니다.\";\n      case 10:\n        return \"OCR 진행중입니다.\";\n      case 11:\n        return \"사본판별 진행중입니다.\";\n      case 16:\n        return \"문서 탐지 진행중입니다.\";\n      default:\n        return \"OCR 진행중입니다.\";\n    }\n  }\n  handleFailedDetection(detectResultCode) {\n    let detectMessage = null;\n    if (detectResultCode !== 0) {\n      this._guideArea.style.border = \"3px solid red\";\n      detectMessage = this.updateTitleBasedOnCode(detectResultCode);\n    }\n    return detectMessage;\n  }\n\n  // updateTitleBasedOnOcrType() {\n  //   this._title.innerHTML = \"\";\n  //   switch (this._ocrType) {\n  //     case 1:\n  //     case 11:\n  //       this._title.innerHTML = \"신분증을 인식중입니다. </br> 잠시만 기다려주세요.\";\n  //       break;\n  //     case 3:\n  //       this._title.innerHTML = \"카드 인식중입니다. </br> 잠시만 기다려주세요.\";\n  //       break;\n  //     case 10:\n  //       this._title.innerHTML = \"지로 인식중입니다. </br> 잠시만 기다려주세요.\";\n  //       break;\n  //     case 16:\n  //       this._title.innerHTML = \"문서 인식중입니다. </br> 잠시만 기다려주세요.\";\n  //       break;\n  //     default:\n  //       break;\n  //   }\n  // }\n\n  async emitCaptureEvent(cropImageData, validCheckDt, resultCode, detectTime) {\n    const eventDetail = {\n      imageData: cropImageData ? cropImageData.imageData : null,\n      imageWidth: cropImageData ? cropImageData.cropWidth : null,\n      imageHeight: cropImageData ? cropImageData.cropHeight : null,\n      currentCount: this._currentCaptueCount,\n      totalCount: this._options.rtcMaxRetryCount,\n      validCheckDt: validCheckDt,\n      rtcToken: this._key,\n      resultCode: cropImageData ? resultCode : null,\n      detectTime: detectTime\n    };\n    this.dispatchEvent(new CustomEvent(\"imagecaptured\", {\n      detail: eventDetail\n    }));\n  }\n  async emitCaptureFileEvent(eventDetail, result, validCheckDt) {\n    const eventDetailFile = {\n      imageData: eventDetail.imageData,\n      imageWidth: eventDetail.imageWidth,\n      imageHeight: eventDetail.imageHeight,\n      currentCount: eventDetail.currentCount,\n      totalCount: eventDetail.totalCount,\n      validCheckDt: validCheckDt,\n      rtcToken: this._key,\n      resultCode: result.resultCode,\n      detectTime: result.detectTime\n    };\n    this.dispatchEvent(new CustomEvent(\"imagecaptured\", {\n      detail: eventDetailFile\n    }));\n  }\n  async handleGiroTypeDetection(imageData, currentGiroType) {\n    this._detectWorker.postMessage({\n      type: \"giroType\",\n      imageData,\n      width: imageData.width,\n      height: imageData.height\n    });\n    const giroType = await new Promise(resolve => {\n      this._detectWorker.onmessage = event => {\n        if (event.data.type == \"giroType\") {\n          resolve(event.data.resultCode);\n        }\n      };\n    });\n\n    // 추후에 지로타입에 따른 UI 변경필요\n    const borderColorMap = {\n      0: \"yellow\",\n      // 기본\n      1: \"red\",\n      // ocr\n      2: \"blue\",\n      // 표준 ocr\n      3: \"green\" // MICR ocr\n    };\n    if (borderColorMap.hasOwnProperty(giroType)) {\n      if (giroType !== 0) {\n        currentGiroType = giroType;\n        this._guideArea.style.border = \"3px solid \".concat(borderColorMap[giroType]);\n      } else if (currentGiroType !== null) {\n        this._guideArea.style.border = \"3px solid \".concat(borderColorMap[currentGiroType]);\n      }\n    } else {\n      console.log(\"nonType\");\n    }\n  }\n  updateTitleID(detectResultCode) {\n    let message = this._previousMessage;\n    switch (detectResultCode) {\n      case 0:\n        // message = \"\";\n        break;\n      case -1:\n        message = \"신분증을 가까이서 촬영해주세요.\"; // 원거리\n        break;\n      case -2:\n        message = \"신분증을 레이아웃 안에 맞춰서 촬영해주세요.\"; // 신분증 잘림(사진)\n        break;\n      case -3:\n        message = \"신분증을 레이아웃 안에 맞춰서 촬영해주세요.\"; // 신분증 기울어짐. 잘림\n        break;\n      case -4:\n        message = \"빛반사를 피하여 신분증을 가리지 않게 촬영해주세요.\"; // 신분증 필드 일부 없음\n        break;\n      case -5:\n        message = \"신분증 영역을 찾을 수 없습니다.\";\n        break;\n      case -6:\n        message = \"신분증 영역을 찾을 수 없습니다.\";\n        break;\n      default:\n        message = \"\";\n    }\n    this._previousMessage = message;\n    return message;\n  }\n  updateTitleCredit(detectResultCode) {\n    let message = this._previousMessage;\n    switch (detectResultCode) {\n      case 0:\n        // message = \"\";\n        break;\n      case -1:\n        message = \"카드를 가까이서 촬영해주세요.\"; // size_ratio, 원거리\n        break;\n      case -2:\n        message = \"카드를 레이아웃 안에 맞춰서 촬영해주세요.\"; // photo_ratio, 카드는 x\n        break;\n      case -3:\n        message = \"카드를 레이아웃 안에 맞춰서 촬영해주세요.\"; // type_ratio, 가로/세로 비율, 잘리거나 기울어진 경우\n        break;\n      case -4:\n        message = \"카드를 가리지 말고 빛반사에 주의하여<br>잘 보이도록 촬영해주세요.\"; // 필드 영역 일부 없음\n        break;\n      case -5:\n        message = \"카드 영역을 찾을 수 없습니다.\"; // 탐지 안됨\n        break;\n      default:\n        message = \"카드를 다시 촬영해주세요.\";\n    }\n    this._previousMessage = message;\n    return message;\n  }\n}\nwindow.WebCamera = WebCamera;\n\n//# sourceURL=webpack://koiOcr/./public/js/koiOcr/webCamera.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".koiOcr.bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "koiOcr:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkkoiOcr"] = self["webpackChunkkoiOcr"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./public/js/koiOcr/koiOcr.js");
/******/ 	window.koiOcr = __webpack_exports__;
/******/ 	
/******/ })()
;